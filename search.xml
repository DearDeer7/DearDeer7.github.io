<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>学习使用Git（二）</title>
      <link href="/xue-xi-shi-yong-git-er/"/>
      <url>/xue-xi-shi-yong-git-er/</url>
      
        <content type="html"><![CDATA[<h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><h2 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h2><p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p><p>你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？</p><p>其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。</p><p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p><p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p><p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p><p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p><pre class="line-numbers language-bash"><code class="language-bash">$ ssh-keygen -t rsa -C <span class="token string">"youremail@example.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p><p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p><p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p><p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105161754.png" alt="github-addkey-1"></p><p>点“Add Key”，你就应该看到已经添加的Key：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105161812.png" alt="github-addkey-2"></p><p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p><p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p><p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p><p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p><p>确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。</p><h2 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h2><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p><p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105162348.png" alt="create repository 1"></p><p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105162439.png" alt="create repository 2"></p><p>目前，在GitHub上的这个<code>learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p><p>现在，我们根据GitHub的提示，在本地的<code>learngit</code>仓库下运行命令：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> remote add origin git@github.com:deardeer7/learngit.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>请千万注意，把上面的<code>deardeer7</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p><p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p><p>下一步，就可以把本地库的所有内容推送到远程库上：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> push -u origin masterEnter passphrase <span class="token keyword">for</span> key <span class="token string">'/c/Users/DearDeer/.ssh/id_rsa'</span><span class="token keyword">:</span>Enumerating objects: 24, done.Counting objects: 100% <span class="token punctuation">(</span>24/24<span class="token punctuation">)</span>, done.Delta compression using up to 8 threadsCompressing objects: 100% <span class="token punctuation">(</span>19/19<span class="token punctuation">)</span>, done.Writing objects: 100% <span class="token punctuation">(</span>24/24<span class="token punctuation">)</span>, 1.94 KiB <span class="token operator">|</span> 330.00 KiB/s, done.Total 24 <span class="token punctuation">(</span>delta 7<span class="token punctuation">)</span>, reused 0 <span class="token punctuation">(</span>delta 0<span class="token punctuation">)</span>, pack-reused 0remote: Resolving deltas: 100% <span class="token punctuation">(</span>7/7<span class="token punctuation">)</span>, done.remote: This repository moved. Please use the new location:remote:   git@github.com:DearDeer7/learngit.gitTo github.com:deardeer7/learngit.git * <span class="token punctuation">[</span>new branch<span class="token punctuation">]</span>      master -<span class="token operator">></span> masterBranch <span class="token string">'master'</span> <span class="token keyword">set</span> up to track remote branch <span class="token string">'master'</span> from <span class="token string">'origin'</span><span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p><p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p><p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105163229.png" alt="create repository 3"></p><p>从现在起，只要本地作了提交，就可以通过命令：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p><h3 id="SSH警告"><a href="#SSH警告" class="headerlink" title="SSH警告"></a>SSH警告</h3><p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p><pre class="line-numbers language-bash"><code class="language-bash">The authenticity of host <span class="token string">'github.com (xx.xx.xx.xx)'</span> can't be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to <span class="token keyword">continue</span> connecting <span class="token punctuation">(</span>yes/no<span class="token punctuation">)</span>?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p><p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p><pre class="line-numbers language-bash"><code class="language-bash">Warning: Permanently added <span class="token string">'github.com'</span> <span class="token punctuation">(</span>RSA<span class="token punctuation">)</span> to the list of known hosts.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p><p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<a href="https://help.github.com/articles/what-are-github-s-ssh-key-fingerprints/" target="_blank" rel="noopener">GitHub的RSA Key的指纹信息</a>是否与SSH连接给出的一致。</p><h2 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h2><p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p><p>首先，登陆GitHub，创建一个新的仓库，名字叫<code>gitskills</code>：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105163601.png" alt="clone repository 1"></p><p>我们勾选<code>Initialize this repository with a README</code>，这样GitHub会自动为我们创建一个<code>README.md</code>文件。创建完毕后，可以看到<code>README.md</code>文件：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105163654.png" alt="clone repository 2"></p><p>现在，远程库已经准备好了，下一步是用命令<code>git clone</code>克隆一个本地库：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> clone git@github.com:DearDeer7/gitskills.gitCloning into <span class="token string">'gitskills'</span><span class="token punctuation">..</span>.Enter passphrase <span class="token keyword">for</span> key <span class="token string">'/c/Users/DearDeer/.ssh/id_rsa'</span><span class="token keyword">:</span>remote: Enumerating objects: 3, done.remote: Counting objects: 100% <span class="token punctuation">(</span>3/3<span class="token punctuation">)</span>, done.remote: Total 3 <span class="token punctuation">(</span>delta 0<span class="token punctuation">)</span>, reused 0 <span class="token punctuation">(</span>delta 0<span class="token punctuation">)</span>, pack-reused 0Receiving objects: 100% <span class="token punctuation">(</span>3/3<span class="token punctuation">)</span>, done.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意把Git库的地址换成你自己的，然后进入<code>gitskills</code>目录看看，已经有<code>README.md</code>文件了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cd</span> gitskills$ <span class="token function">ls</span>    目录: C:\Users\DearDeer\desktop\gitskillsMode                 LastWriteTime         Length Name----                 -------------         ------ -----a----          2021/1/5     16:38             11 README.md<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p><p>你也许还注意到，GitHub给出的地址不止一个，还可以用<code>https://github.com/DearDeer7/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</p><p>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</p><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><p>分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。</p><p>如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105164240.png" alt="learn-branches"></p><p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p><p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p><p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p><p>但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p><h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><p>在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p><p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105193921.png" alt="git-br-initial"></p><p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p><p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105193952.png" alt="git-br-create"></p><p>你看，Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p><p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105193955.png" alt="git-br-dev-fd"></p><p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105193959.png" alt="git-br-ff-merge"></p><p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p><p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105194002.png" alt="git-br-rm"></p><p>真是太神奇了，你看得出来有些提交是通过分支完成的吗？</p><p>下面开始实战。</p><p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> checkout -b devSwitched to a new branch <span class="token string">'dev'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> branch dev$ <span class="token function">git</span> checkout devSwitched to branch <span class="token string">'dev'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后，用<code>git branch</code>命令查看当前分支：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> branch* dev  master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p><p>然后，我们就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，加上一行：</p><pre class="line-numbers language-bash"><code class="language-bash">Creating a new branch is quick.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后提交：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add readme.txt $ <span class="token function">git</span> commit -m <span class="token string">"branch test"</span><span class="token punctuation">[</span>dev b17d20e<span class="token punctuation">]</span> branch <span class="token function">test</span> 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> checkout masterSwitched to branch <span class="token string">'master'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105205628.png" alt="git-br-on-master"></p><p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> merge devUpdating d46f35e<span class="token punctuation">..</span>b17d20eFast-forward readme.txt <span class="token operator">|</span> 1 + 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>readme.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p><p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p><p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p><p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> branch -d devDeleted branch dev <span class="token punctuation">(</span>was b17d20e<span class="token punctuation">)</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> branch* master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>我们注意到切换分支使用<code>git checkout</code>，而前面讲过的撤销修改则是<code>git checkout --</code>，同一个命令，有两种作用，确实有点令人迷惑。</p><p>实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p><p>创建并切换到新的<code>dev</code>分支，可以使用：</p><pre><code>$ git switch -c dev</code></pre><p>直接切换到已有的<code>master</code>分支，可以使用：</p><pre><code>$ git switch master</code></pre><p>使用新的<code>git switch</code>命令，比<code>git checkout</code>要更容易理解。</p><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p><p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> switch -c feature1Switched to a new branch <span class="token string">'feature1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改<code>readme.txt</code>最后一行，改为：</p><pre class="line-numbers language-bash"><code class="language-bash">Creating a new branch is quick AND simple.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在<code>feature1</code>分支上提交：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add readme.txt$ <span class="token function">git</span> commit -m <span class="token string">"AND simple"</span><span class="token punctuation">[</span>feature1 14096d0<span class="token punctuation">]</span> AND simple 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, 1 deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切换到<code>master</code>分支：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> switch masterSwitched to branch <span class="token string">'master'</span>Your branch is ahead of <span class="token string">'origin/master'</span> by 1 commit.  <span class="token punctuation">(</span>use <span class="token string">"git push"</span> to publish your local commits<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p><p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p><pre class="line-numbers language-bash"><code class="language-bash">Creating a new branch is quick <span class="token operator">&amp;</span> simple.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>提交：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add readme.txt $ <span class="token function">git</span> commit -m <span class="token string">"&amp; simple"</span><span class="token punctuation">[</span>master 5dc6824<span class="token punctuation">]</span> <span class="token operator">&amp;</span> simple 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, 1 deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105212318.png" alt="git-br-feature1"></p><p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> merge feature1Auto-merging readme.txtCONFLICT <span class="token punctuation">(</span>content<span class="token punctuation">)</span>: Merge conflict <span class="token keyword">in</span> readme.txtAutomatic merge failed<span class="token punctuation">;</span> fix conflicts and <span class="token keyword">then</span> commit the result.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterYour branch is ahead of <span class="token string">'origin/master'</span> by 2 commits.  <span class="token punctuation">(</span>use <span class="token string">"git push"</span> to publish your local commits<span class="token punctuation">)</span>You have unmerged paths.  <span class="token punctuation">(</span>fix conflicts and run <span class="token string">"git commit"</span><span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git merge --abort"</span> to abort the merge<span class="token punctuation">)</span>Unmerged paths:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file>..."</span> to mark resolution<span class="token punctuation">)</span>    both modified:   readme.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以直接查看readme.txt的内容：</p><pre class="line-numbers language-bash"><code class="language-bash">Git is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.<span class="token operator">&lt;&lt;&lt;</span><span class="token operator">&lt;&lt;&lt;</span><span class="token operator">&lt;</span> HEADCreating a new branch is quick <span class="token operator">&amp;</span> simple.<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span>Creating a new branch is quick AND simple.<span class="token operator">>></span><span class="token operator">>></span><span class="token operator">>></span><span class="token operator">></span> feature1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p><pre class="line-numbers language-bash"><code class="language-bash">Creating a new branch is quick and simple.<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再提交：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add readme.txt $ <span class="token function">git</span> commit -m <span class="token string">"conflict fixed"</span><span class="token punctuation">[</span>master cf810e4<span class="token punctuation">]</span> conflict fixed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105212435.png" alt="git-br-conflict-merged"></p><p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> log --graph --pretty<span class="token operator">=</span>oneline --abbrev-commit*   cf810e4 <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> master<span class="token punctuation">)</span> conflict fixed<span class="token operator">|</span>\  <span class="token operator">|</span> * 14096d0 <span class="token punctuation">(</span>feature1<span class="token punctuation">)</span> AND simple* <span class="token operator">|</span> 5dc6824 <span class="token operator">&amp;</span> simple<span class="token operator">|</span>/  * b17d20e branch <span class="token function">test</span>* d46f35e <span class="token punctuation">(</span>origin/master<span class="token punctuation">)</span> remove test.txt* b84166e add test.txt* 519219b <span class="token function">git</span> tracks changes* e43a48b understand how stage works* 1094adb append GPL* e475afc add distributed* eaadf4e wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后，删除<code>feature1</code>分支：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> branch -d feature1Deleted branch feature1 <span class="token punctuation">(</span>was 14096d0<span class="token punctuation">)</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>工作完成。</p><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p><p>下面我们实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p><p>首先，仍然创建并切换<code>dev</code>分支：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> switch -c devSwitched to a new branch <span class="token string">'dev'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>修改readme.txt文件，并提交一个新的commit：</p><pre class="line-numbers language-bash"><code class="language-bash">bash$ <span class="token function">git</span> add readme.txt $ <span class="token function">git</span> commit -m <span class="token string">"add merge"</span><span class="token punctuation">[</span>dev f52c633<span class="token punctuation">]</span> add merge 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>现在，我们切换回<code>master</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> switch masterSwitched to branch <span class="token string">'master'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> merge --no-ff -m <span class="token string">"merge with no-ff"</span> devMerge made by the <span class="token string">'recursive'</span> strategy. readme.txt <span class="token operator">|</span> 1 + 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p><p>合并后，我们用<code>git log</code>看看分支历史：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> log --graph --pretty<span class="token operator">=</span>oneline --abbrev-commit*   e1e9c68 <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> master<span class="token punctuation">)</span> merge with no-ff<span class="token operator">|</span>\  <span class="token operator">|</span> * f52c633 <span class="token punctuation">(</span>dev<span class="token punctuation">)</span> add merge<span class="token operator">|</span>/  *   cf810e4 conflict fixed<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210106103530.png" alt="git-no-ff-mode"></p><h3 id="分支策略"><a href="#分支策略" class="headerlink" title="分支策略"></a>分支策略</h3><p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p><p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p><p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p><p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p><p>所以，团队合作的分支看起来就像这样：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210106103611.png" alt="git-br-policy"></p><h2 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h2><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p><p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch devChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file>..."</span> to unstage<span class="token punctuation">)</span>    new file:   hello.pyChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file>..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file>..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>    modified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p><p>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> stashSaved working directory and index state WIP on dev: f52c633 add merge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p><p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> checkout masterSwitched to branch <span class="token string">'master'</span>Your branch is ahead of <span class="token string">'origin/master'</span> by 6 commits.  <span class="token punctuation">(</span>use <span class="token string">"git push"</span> to publish your local commits<span class="token punctuation">)</span>$ <span class="token function">git</span> checkout -b issue-101Switched to a new branch <span class="token string">'issue-101'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add readme.txt $ <span class="token function">git</span> commit -m <span class="token string">"fix bug 101"</span><span class="token punctuation">[</span>issue-101 4c805e2<span class="token punctuation">]</span> fix bug 101 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, 1 deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> switch masterSwitched to branch <span class="token string">'master'</span>Your branch is ahead of <span class="token string">'origin/master'</span> by 6 commits.  <span class="token punctuation">(</span>use <span class="token string">"git push"</span> to publish your local commits<span class="token punctuation">)</span>$ <span class="token function">git</span> merge --no-ff -m <span class="token string">"merged bug fix 101"</span> issue-101Merge made by the <span class="token string">'recursive'</span> strategy. readme.txt <span class="token operator">|</span> 2 +- 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, 1 deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到<code>dev</code>分支干活了！</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> switch devSwitched to branch <span class="token string">'dev'</span>$ <span class="token function">git</span> statusOn branch devnothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> stash liststash@<span class="token punctuation">{</span>0<span class="token punctuation">}</span>: WIP on dev: f52c633 add merge<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p><p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p><p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> stash popOn branch devChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file>..."</span> to unstage<span class="token punctuation">)</span>    new file:   hello.pyChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file>..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git checkout -- &lt;file>..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>    modified:   readme.txtDropped refs/stash@<span class="token punctuation">{</span>0<span class="token punctuation">}</span> <span class="token punctuation">(</span>5d677e2ee266f39ea296182fb2354265b91b3b2a<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> stash list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> stash apply stash@<span class="token punctuation">{</span>0<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。</p><p>那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？</p><p>有木有更简单的方法？</p><p>有！</p><p>同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。</p><p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> branch* dev  master$ <span class="token function">git</span> cherry-pick 4c805e2<span class="token punctuation">[</span>master 1d4b803<span class="token punctuation">]</span> fix bug 101 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, 1 deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p><p>有些聪明的童鞋会想了，既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要<code>git stash</code>命令保存现场，才能从dev分支切换到master分支。</p><h2 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h2><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p><p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p><p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p><p>于是准备开发：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> switch -c feature-vulcanSwitched to a new branch <span class="token string">'feature-vulcan'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>5分钟后，开发完毕：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add vulcan.py$ <span class="token function">git</span> statusOn branch feature-vulcanChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git reset HEAD &lt;file>..."</span> to unstage<span class="token punctuation">)</span>    new file:   vulcan.py$ <span class="token function">git</span> commit -m <span class="token string">"add feature vulcan"</span><span class="token punctuation">[</span>feature-vulcan 287773e<span class="token punctuation">]</span> add feature vulcan 1 <span class="token function">file</span> changed, 2 insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode 100644 vulcan.py<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>切回<code>dev</code>，准备合并：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> switch dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p><p>但是！</p><p>就在此时，接到上级命令，因经费不足，新功能必须取消！</p><p>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> branch -d feature-vulcanerror: The branch <span class="token string">'feature-vulcan'</span> is not fully merged.If you are sure you want to delete it, run <span class="token string">'git branch -D feature-vulcan'</span><span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的<code>-D</code>参数。。</p><p>现在我们强行删除：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> branch -D feature-vulcanDeleted branch feature-vulcan <span class="token punctuation">(</span>was 287773e<span class="token punctuation">)</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>终于删除成功！</p><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p><p>要查看远程库的信息，用<code>git remote</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> remoteorigin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>或者，用<code>git remote -v</code>显示更详细的信息：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> remote -vorigin  git@github.com:DearDeer7/learngit.git <span class="token punctuation">(</span>fetch<span class="token punctuation">)</span>origin  git@github.com:DearDeer7/learngit.git <span class="token punctuation">(</span>push<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p><h3 id="推送分支"><a href="#推送分支" class="headerlink" title="推送分支"></a>推送分支</h3><p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> push origin master<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果要推送其他分支，比如<code>dev</code>，就改成：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> push origin dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p><ul><li><code>master</code>分支是主分支，因此要时刻与远程同步；</li><li><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</li><li>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</li><li>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</li></ul><p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p><h3 id="抓取分支"><a href="#抓取分支" class="headerlink" title="抓取分支"></a>抓取分支</h3><p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p><p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> clone git@github.com:DearDeer7/learngit.gitCloning into <span class="token string">'learngit'</span><span class="token punctuation">..</span>.remote: Counting objects: 40, done.remote: Compressing objects: 100% <span class="token punctuation">(</span>21/21<span class="token punctuation">)</span>, done.remote: Total 40 <span class="token punctuation">(</span>delta 14<span class="token punctuation">)</span>, reused 40 <span class="token punctuation">(</span>delta 14<span class="token punctuation">)</span>, pack-reused 0Receiving objects: 100% <span class="token punctuation">(</span>40/40<span class="token punctuation">)</span>, done.Resolving deltas: 100% <span class="token punctuation">(</span>14/14<span class="token punctuation">)</span>, done.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> branch* master<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> checkout -b dev origin/dev<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add env.txt$ <span class="token function">git</span> commit -m <span class="token string">"add env"</span><span class="token punctuation">[</span>dev 7a5e5dd<span class="token punctuation">]</span> add <span class="token function">env</span> 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode 100644 env.txt$ <span class="token function">git</span> push origin devCounting objects: 3, done.Delta compression using up to 4 threads.Compressing objects: 100% <span class="token punctuation">(</span>2/2<span class="token punctuation">)</span>, done.Writing objects: 100% <span class="token punctuation">(</span>3/3<span class="token punctuation">)</span>, 308 bytes <span class="token operator">|</span> 308.00 KiB/s, done.Total 3 <span class="token punctuation">(</span>delta 0<span class="token punctuation">)</span>, reused 0 <span class="token punctuation">(</span>delta 0<span class="token punctuation">)</span>To github.com:DearDeer7/learngit.git   f52c633<span class="token punctuation">..</span>7a5e5dd  dev -<span class="token operator">></span> dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> env.txt<span class="token function">env</span>$ <span class="token function">git</span> add env.txt$ <span class="token function">git</span> commit -m <span class="token string">"add new env"</span><span class="token punctuation">[</span>dev 7bd91f1<span class="token punctuation">]</span> add new <span class="token function">env</span> 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode 100644 env.txt$ <span class="token function">git</span> push origin devTo github.com:DearDeer7/learngit.git <span class="token operator">!</span> <span class="token punctuation">[</span>rejected<span class="token punctuation">]</span>        dev -<span class="token operator">></span> dev <span class="token punctuation">(</span>non-fast-forward<span class="token punctuation">)</span>error: failed to push some refs to <span class="token string">'git@github.com:DearDeer7/learngit.git'</span>hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes <span class="token punctuation">(</span>e.g.hint: <span class="token string">'git pull ...'</span><span class="token punctuation">)</span> before pushing again.hint: See the <span class="token string">'Note about fast-forwards'</span> <span class="token keyword">in</span> <span class="token string">'git push --help'</span> <span class="token keyword">for</span> details.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> pullThere is no tracking information <span class="token keyword">for</span> the current branch.Please specify <span class="token function">which</span> branch you want to merge with.See git-pull<span class="token punctuation">(</span>1<span class="token punctuation">)</span> <span class="token keyword">for</span> details.    <span class="token function">git</span> pull <span class="token operator">&lt;</span>remote<span class="token operator">></span> <span class="token operator">&lt;</span>branch<span class="token operator">></span>If you wish to <span class="token keyword">set</span> tracking information <span class="token keyword">for</span> this branch you can <span class="token keyword">do</span> so with:    <span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/<span class="token operator">&lt;</span>branch<span class="token operator">></span> dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> branch --set-upstream-to<span class="token operator">=</span>origin/dev devBranch <span class="token string">'dev'</span> <span class="token keyword">set</span> up to track remote branch <span class="token string">'dev'</span> from <span class="token string">'origin'</span><span class="token keyword">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>再pull：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> pullAuto-merging env.txtCONFLICT <span class="token punctuation">(</span>add/add<span class="token punctuation">)</span>: Merge conflict <span class="token keyword">in</span> env.txtAutomatic merge failed<span class="token punctuation">;</span> fix conflicts and <span class="token keyword">then</span> commit the result.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的<a href="http://www.liaoxuefeng.com/wiki/896043488029600/900004111093344" target="_blank" rel="noopener">解决冲突</a>完全一样。解决后，提交，再push：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> commit -m <span class="token string">"fix env conflict"</span><span class="token punctuation">[</span>dev 57c53ab<span class="token punctuation">]</span> fix <span class="token function">env</span> conflict$ <span class="token function">git</span> push origin devCounting objects: 6, done.Delta compression using up to 4 threads.Compressing objects: 100% <span class="token punctuation">(</span>4/4<span class="token punctuation">)</span>, done.Writing objects: 100% <span class="token punctuation">(</span>6/6<span class="token punctuation">)</span>, 621 bytes <span class="token operator">|</span> 621.00 KiB/s, done.Total 6 <span class="token punctuation">(</span>delta 0<span class="token punctuation">)</span>, reused 0 <span class="token punctuation">(</span>delta 0<span class="token punctuation">)</span>To github.com:DearDeer7/learngit.git   7a5e5dd<span class="token punctuation">..</span>57c53ab  dev -<span class="token operator">></span> dev<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>因此，多人协作的工作模式通常是这样：</p><ol><li>首先，可以试图用<code>git push origin</code>推送自己的修改；</li><li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li><li>如果合并有冲突，则解决冲突，并在本地提交；</li><li>没有冲突或者解决掉冲突后，再用<code>git push origin</code>推送就能成功！</li></ol><p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to  origin/</code>。</p><p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p><h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p><p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p><p>Git有commit，为什么还要引入tag？</p><p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p><p>“一串乱七八糟的数字不好找！”</p><p>如果换一个办法：</p><p>“请把上周一的那个版本打包发布，版本号是v1.2”</p><p>“好的，按照tag v1.2查找commit就行！”</p><p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p><h3 id="标签创建"><a href="#标签创建" class="headerlink" title="标签创建"></a>标签创建</h3><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> branch* dev  master$ <span class="token function">git</span> checkout masterSwitched to branch <span class="token string">'master'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，敲命令<code>git tag</code>就可以打一个新标签：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> tag v1.0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以用命令<code>git tag</code>查看所有标签：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> tagv1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p><p>方法是找到历史提交的commit id，然后打上就可以了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> log --pretty<span class="token operator">=</span>oneline --abbrev-commit12a631b <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> master, tag: v1.0, origin/master<span class="token punctuation">)</span> merged bug fix 1014c805e2 fix bug 101e1e9c68 merge with no-fff52c633 add mergecf810e4 conflict fixed5dc6824 <span class="token operator">&amp;</span> simple14096d0 AND simpleb17d20e branch <span class="token function">test</span>d46f35e remove test.txtb84166e add test.txt519219b <span class="token function">git</span> tracks changese43a48b understand how stage works1094adb append GPLe475afc add distributedeaadf4e wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> tag v0.9 f52c633<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再用命令<code>git tag</code>查看标签：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> tagv0.9v1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show</code>查看标签信息：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> show v0.9commit f52c63349bc3c1593499807e5c8e972b82c8f286 <span class="token punctuation">(</span>tag: v0.9<span class="token punctuation">)</span>Author: DearDeer7 <span class="token operator">&lt;</span>deardeer0091@163.com<span class="token operator">></span>Date:   Wed Jan 6 21:06:15 2021 +0800    add merge<span class="token function">diff</span> --git a/readme.txt b/readme.txt<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p><p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> tag -a v0.1 -m <span class="token string">"version 0.1 released"</span> 1094adb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用命令<code>git show</code>可以看到说明文字：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> show v0.1tag v0.1Tagger: DearDeer7 <span class="token operator">&lt;</span>deardeer0091@163.com<span class="token operator">></span>Date:   Wed Jan 6 22:48:43  2021 +0800version 0.1 releasedcommit 1094adb7b9b3807259d8cb349e7df1d4d6477073 <span class="token punctuation">(</span>tag: v0.1<span class="token punctuation">)</span>Author: DearDeer7 <span class="token operator">&lt;</span>deardeer0091@163.com<span class="token operator">></span>Date:   Wed Jan 6 21:10:15 2021 +0800    append GPL<span class="token function">diff</span> --git a/readme.txt b/readme.txt<span class="token punctuation">..</span>.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p><h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>如果标签打错了，也可以删除：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> tag -d v0.1Deleted tag <span class="token string">'v0.1'</span> <span class="token punctuation">(</span>was f15b0dd<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p><p>如果要推送某个标签到远程，使用命令<code>git push origin</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> push origin v1.0Total 0 <span class="token punctuation">(</span>delta 0<span class="token punctuation">)</span>, reused 0 <span class="token punctuation">(</span>delta 0<span class="token punctuation">)</span>To github.com:DearDeer7/learngit.git * <span class="token punctuation">[</span>new tag<span class="token punctuation">]</span>         v1.0 -<span class="token operator">></span> v1.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>或者，一次性推送全部尚未推送到远程的本地标签：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> push origin --tagsTotal 0 <span class="token punctuation">(</span>delta 0<span class="token punctuation">)</span>, reused 0 <span class="token punctuation">(</span>delta 0<span class="token punctuation">)</span>To github.com:DearDeer7/learngit.git * <span class="token punctuation">[</span>new tag<span class="token punctuation">]</span>         v0.9 -<span class="token operator">></span> v0.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> tag -d v0.9Deleted tag <span class="token string">'v0.9'</span> <span class="token punctuation">(</span>was f52c633<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后，从远程删除。删除命令也是push，但是格式如下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> push origin :refs/tags/v0.9To github.com:DearDeer7/learngit.git - <span class="token punctuation">[</span>deleted<span class="token punctuation">]</span>         v0.9<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</li><li>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</li><li>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</li></ul><ul><li>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</li><li>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</li></ul><ul><li>Git鼓励大量使用分支：</li><li>查看分支：<code>git branch</code></li><li>创建分支：<code>git branch</code></li><li>切换分支：<code>git checkout</code>或者<code>git switch</code></li><li>创建+切换分支：<code>git checkout -b</code>或者<code>git switch -c</code></li><li>合并某分支到当前分支：<code>git merge</code></li><li>删除分支：<code>git branch -d</code></li></ul><ul><li><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p><p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p><p>用<code>git log --graph</code>命令可以看到分支合并图。</p></li></ul><ul><li>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</li></ul><ul><li>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</li><li>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；</li><li>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</li></ul><ul><li>开发一个新feature，最好新建一个分支；</li><li>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D</code>强行删除。</li></ul><ul><li>查看远程库信息，使用<code>git remote -v</code>；</li><li>本地新建的分支如果不推送到远程，对其他人就是不可见的；</li><li>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</li><li>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</li><li>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</li><li>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</li></ul><ul><li>rebase操作可以把本地未push的分叉提交历史整理成直线；</li><li>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</li></ul><ul><li>命令<code>git tag</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</li><li>命令<code>git tag -a  -m "blablabla..."</code>可以指定标签信息；</li><li>命令<code>git tag</code>可以查看所有标签。</li></ul><ul><li>命令<code>git push origin</code>可以推送一个本地标签；</li><li>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</li><li>命令<code>git tag -d</code>可以删除一个本地标签；</li><li>命令<code>git push origin :refs/tags/</code>可以删除一个远程标签。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 教程 </tag>
            
            <tag> CLI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习使用Git（一）</title>
      <link href="/xue-xi-shi-yong-git-yi/"/>
      <url>/xue-xi-shi-yong-git-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h1><h2 id="Git-是什么"><a href="#Git-是什么" class="headerlink" title="Git 是什么"></a>Git 是什么</h2><p><a href="https://git-scm.com/" target="_blank" rel="noopener"><strong>Git</strong></a>是一款免费、开源的<strong>分布式版本控制系统</strong>，用于敏捷高效地处理任何或小或大的项目。</p><p>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 <strong>Linus Torvalds</strong> 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p><h2 id="Git-特点"><a href="#Git-特点" class="headerlink" title="Git 特点"></a>Git 特点</h2><p><strong>优点</strong>：</p><ul><li><p>适合分布式开发，强调个体；</p></li><li><p>公共服务器压力和数据量都不会太大；</p></li><li><p>速度快、灵活；</p></li><li><p>任意两个开发者之间可以很容易的解决冲突；</p></li><li><p>离线工作。</p></li></ul><p><strong>缺点</strong>：</p><ul><li><p>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息；</p></li><li><p>权限控制不友好；如果需要对开发者限制各种权限的建议使用SVN。</p></li></ul><h1 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h1><h3 id="在Linux上安装Git"><a href="#在Linux上安装Git" class="headerlink" title="在Linux上安装Git"></a>在Linux上安装Git</h3><p>首先，你可以试着输入<code>git</code>，看看系统有没有安装Git：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span>The program <span class="token string">'git'</span> is currently not installed. You can <span class="token function">install</span> it by typing:<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p><p>如果你碰巧用Debian或Ubuntu Linux，通过一条<code>sudo apt-get install git</code>就可以直接完成Git的安装，非常简单。</p><p>老一点的Debian或Ubuntu Linux，要把命令改为<code>sudo apt-get install git-core</code>，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫<code>git-core</code>了。由于Git名气实在太大，后来就把GNU Interactive Tools改成<code>gnuit</code>，<code>git-core</code>正式改为<code>git</code>。</p><p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code>这几个命令安装就好了。</p><h3 id="在Mac-OS-X上安装Git"><a href="#在Mac-OS-X上安装Git" class="headerlink" title="在Mac OS X上安装Git"></a>在Mac OS X上安装Git</h3><p>如果你正在使用Mac做开发，有两种安装Git的方法。</p><p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/。" target="_blank" rel="noopener">http://brew.sh/。</a></p><p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105102730.jpeg" alt="install-git-by-xcode"></p><p>Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！</p><h3 id="在Windows上安装Git"><a href="#在Windows上安装Git" class="headerlink" title="在Windows上安装Git"></a>在Windows上安装Git</h3><p>在Windows上使用Git，可以从Git官网直接<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载安装程序</a>，然后按默认选项安装即可。</p><p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105102951.png" alt="Windows上的 Git Bash"></p><p>安装完成后，还需要最后一步设置，在命令行输入：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> config --global user.name <span class="token string">"Your Name"</span>$ <span class="token function">git</span> config --global user.email <span class="token string">"email@example.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><h2 id="创建空版本库"><a href="#创建空版本库" class="headerlink" title="创建空版本库"></a>创建空版本库</h2><p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> learngit$ <span class="token function">cd</span> learngit$ <span class="token function">pwd</span>Path----C:\Users\DearDeer\desktop\learngit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>pwd</code>命令用于显示当前目录。如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105103542.png" alt="创建版本库"></p><p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> initInitialized empty Git repository <span class="token keyword">in</span> C:/Users/DearDeer/Desktop/learngit/.git/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><p>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p><p>也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。</p><h2 id="添加文件到版本库"><a href="#添加文件到版本库" class="headerlink" title="添加文件到版本库"></a>添加文件到版本库</h2><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><p>使用Windows的童鞋要特别注意：</p><p>千万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<a href="http://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a>代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105104250.png" alt="设置notepad++编码"></p><p>言归正传，现在我们编写一个<code>readme.txt</code>文件，内容如下：</p><pre class="line-numbers language-bash"><code class="language-bash">Git is a version control system.Git is <span class="token function">free</span> software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>一定要放到<code>learngit</code>目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p><p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p><p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> commit -m <span class="token string">"wrote a readme file"</span><span class="token punctuation">[</span>master <span class="token punctuation">(</span>root-commit<span class="token punctuation">)</span> c2a7d3b<span class="token punctuation">]</span> wrote a readme <span class="token function">file</span> 1 <span class="token function">file</span> changed, 2 insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode 100644 readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>嫌麻烦不想输入<code>-m "xxx"</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p><p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p><p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add file1.txt$ <span class="token function">git</span> add file2.txt file3.txt$ <span class="token function">git</span> commit -m <span class="token string">"add 3 files."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="疑难解答"><a href="#疑难解答" class="headerlink" title="疑难解答"></a>疑难解答</h2><p>Q：输入<code>git add readme.txt</code>，得到错误：<code>fatal: not a git repository (or any of the parent directories)</code>。</p><p>A：Git命令必须在Git仓库目录内执行（<code>git init</code>除外），在仓库目录外执行是没有意义的。</p><p>Q：输入<code>git add readme.txt</code>，得到错误<code>fatal: pathspec 'readme.txt' did not match any files</code>。</p><p>A：添加某个文件时，该文件必须在当前目录下存在，用<code>ls</code>或者<code>dir</code>命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名。</p><h1 id="Git-版本控制"><a href="#Git-版本控制" class="headerlink" title="Git 版本控制"></a>Git 版本控制</h1><h2 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h2><p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：</p><pre class="line-numbers language-bash"><code class="language-bash">Git is a distributed version control system.Git is <span class="token function">free</span> software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，运行<code>git status</code>命令看看结果：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file>..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git restore &lt;file>..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>    modified:   readme.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p><p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用<code>git diff</code>这个命令看看：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> readme.txt <span class="token function">diff</span> --git a/readme.txt b/readme.txtindex 46d49bf<span class="token punctuation">..</span>9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is <span class="token function">free</span> software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p><p>知道了对<code>readme.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git restore --staged &lt;file>..."</span> to unstage<span class="token punctuation">)</span>    modified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git status</code>告诉我们，将要被提交的修改包括<code>readme.txt</code>，下一步，就可以放心地提交了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> commit -m <span class="token string">"add distributed"</span><span class="token punctuation">[</span>master ce544e3<span class="token punctuation">]</span> add distributed 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, 1 deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提交后，我们再用<code>git status</code>命令看看仓库的当前状态：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masternothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p><pre class="line-numbers language-bash"><code class="language-bash">Git is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后尝试提交：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add readme.txt$ <span class="token function">git</span> commit -m <span class="token string">"append GPL"</span><span class="token punctuation">[</span>master df09e99<span class="token punctuation">]</span> append GPL 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, 1 deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p><p>现在，我们回顾一下<code>readme.txt</code>文件一共有几个版本被提交到Git仓库里了：</p><p>版本1：wrote a readme file</p><pre class="line-numbers language-bash"><code class="language-bash">Git is a version control system.Git is <span class="token function">free</span> software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>版本2：add distributed</p><pre class="line-numbers language-bash"><code class="language-bash">Git is a distributed version control system.Git is <span class="token function">free</span> software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>版本3：append GPL</p><pre class="line-numbers language-bash"><code class="language-bash">Git is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> logAuthor: DearDeer7 <span class="token operator">&lt;</span>deardeer0091@163.com<span class="token operator">></span>Date:   Tue Jan 5 10:59:41 2021 +0800    add GPLcommit ce544e3e9e43af38c459f83a400e622ecc4919c9Date:   Tue Jan 5 10:53:52 2021 +0800    add distributedcommit c2a7d3baae628dffda4fb32e363c72607db9a5ddAuthor: DearDeer7 <span class="token operator">&lt;</span>deardeer0091@163.com<span class="token operator">></span>Date:   Tue Jan 5 10:10:34 2021 +0800    wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> log --pretty<span class="token operator">=</span>onelinedf09e994aa48bcef68ed696ee0d39164a647c698 <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> master<span class="token punctuation">)</span> add GPLce544e3e9e43af38c459f83a400e622ecc4919c9 add distributedc2a7d3baae628dffda4fb32e363c72607db9a5dd wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要友情提示的是，你看到的一大串类似<code>df09e9...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105111620.png" alt="git-log-timeline"></p><p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>df09e9...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> reset --hard HEAD^HEAD is now at ce544e3 add distributed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p><p>看看<code>readme.txt</code>的内容是不是版本<code>add distributed</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>果然被还原了。</p><p>还可以继续回退到上一个版本<code>wrote a readme file</code>，不过且慢，让我们用<code>git log</code>再看看现在版本库的状态：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> logcommit ce544e3e9e43af38c459f83a400e622ecc4919c9 <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> master<span class="token punctuation">)</span>Author: DearDeer7 <span class="token operator">&lt;</span>deardeer0091@163.com<span class="token operator">></span>Date:   Tue Jan 5 10:53:52 2021 +0800    add distributedcommit c2a7d3baae628dffda4fb32e363c72607db9a5ddAuthor: DearDeer7 <span class="token operator">&lt;</span>deardeer0091@163.com<span class="token operator">></span>Date:   Tue Jan 5 10:10:34 2021 +0800    wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p><p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>df09e99...</code>，于是就可以指定回到未来的某个版本：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> reset --hard df09e99HEAD is now at df09e99 append GPL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p><p>再小心翼翼地看看<code>readme.txt</code>的内容：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>果然，我胡汉三又回来了。</p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p><pre class="line-numbers language-ascii"><code class="language-ascii">┌────┐│HEAD│└────┘   │   └──> ○ append GPL        │        ○ add distributed        │        ○ wrote a readme file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改为指向<code>add distributed</code>：</p><pre class="line-numbers language-ascii"><code class="language-ascii">┌────┐│HEAD│└────┘   │   │    ○ append GPL   │    │   └──> ○ add distributed        │        ○ wrote a readme file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> reflogdf09e99 <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> master<span class="token punctuation">)</span> HEAD@<span class="token punctuation">{</span>0<span class="token punctuation">}</span>: reset: moving to df09e99ce544e3 HEAD@<span class="token punctuation">{</span>1<span class="token punctuation">}</span>: reset: moving to HEAD^df09e99 <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> master<span class="token punctuation">)</span> HEAD@<span class="token punctuation">{</span>2<span class="token punctuation">}</span>: commit: add GPLce544e3 HEAD@<span class="token punctuation">{</span>3<span class="token punctuation">}</span>: commit: add distributedc2a7d3b HEAD@<span class="token punctuation">{</span>4<span class="token punctuation">}</span>: commit <span class="token punctuation">(</span>initial<span class="token punctuation">)</span>: wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>终于舒了口气，从输出可知，<code>append GPL</code>的commit id是<code>df09e99</code>，现在，你又可以乘坐时光机回到未来了。</p><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p><p>先来看名词解释。</p><h3 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h3><p>就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105133641.png" alt="learngit工作区"></p><h3 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h3><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105133713.jpeg" alt="git-repo"></p><p>分支和<code>HEAD</code>的概念我们以后再讲。</p><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><p>俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：</p><pre class="line-numbers language-bash"><code class="language-bash">Git is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p><p>先用<code>git status</code>查看一下状态：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file>..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git restore &lt;file>..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>    modified:   readme.txtUntracked files:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file>..."</span> to include <span class="token keyword">in</span> what will be committed<span class="token punctuation">)</span>    LICENSEno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p><p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git restore --staged &lt;file>..."</span> to unstage<span class="token punctuation">)</span>    new file:   LICENSE    modified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，暂存区的状态就变成这样了：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105134103.jpeg" alt="git-stage"></p><p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> commit -m <span class="token string">"understand how stage works"</span><span class="token punctuation">[</span>master e43a48b<span class="token punctuation">]</span> understand how stage works 2 files changed, 2 insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode 100644 LICENSE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masternothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在版本库变成了这样，暂存区就没有任何内容了：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105134355.jpeg" alt="git-stage-after-commit"></p><h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><p>现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p><p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p><p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，添加：</p><pre><code>$ git add readme.txt$ git statusOn branch masterChanges to be committed:  (use "git restore --staged &lt;file&gt;..." to unstage)        modified:   readme.txt</code></pre><p>然后，再修改readme.txt：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txt Git is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提交：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> commit -m <span class="token string">"git tracks changes"</span><span class="token punctuation">[</span>master 2bdee35<span class="token punctuation">]</span> <span class="token function">git</span> tracks changes 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提交后，再看看状态：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch master  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file>..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git restore &lt;file>..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>        modified:   readme.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>咦，怎么第二次的修改没有被提交？</p><p>别激动，我们回顾一下操作过程：</p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p><p>你看，我们前面讲了，Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> HEAD -- readme.txt <span class="token function">diff</span> --git a/readme.txt b/readme.txtindex 8d86265<span class="token punctuation">..</span>ffa9ce8 100644--- a/readme.txt+++ b/readme.txt@@ -1,4 +1,4 @@ Git is a distributed version control system. Git is a <span class="token function">free</span> software distributed under the GPL. Git has a mutable index called stage.-Git tracks changes.\ No newline at end of <span class="token function">file</span>+Git tracks changes of files.\ No newline at end of <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，第二次修改确实没有被提交。</p><p>那怎么提交第二次修改呢？你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了：</p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在<code>readme.txt</code>中添加了一行：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在你准备提交前，一杯咖啡起了作用，你猛然发现了<code>stupid boss</code>可能会让你丢掉这个月的奖金！</p><p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file>..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git restore &lt;file>..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>        modified:   readme.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以发现，Git会告诉你，<code>git restore &lt;file&gt;</code>可以丢弃工作区的修改：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> restore readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令<code>git restore readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>现在，看看<code>readme.txt</code>的文件内容：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件内容果然复原了。</p><p>现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.$ <span class="token function">git</span> add readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git restore --staged &lt;file>..."</span> to unstage<span class="token punctuation">)</span>        modified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Git同样告诉我们，用命令<code>git restore --staged &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> restore --staged readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file>..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git restore &lt;file>..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>        modified:   readme.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还记得如何丢弃工作区的修改吗？</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> restore readme.txt$ <span class="token function">git</span> statusOn branch masternothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整个世界终于清静了！</p><p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把<code>stupid boss</code>提交推送到远程版本库，你就真的惨了……</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add test.txt$ <span class="token function">git</span> commit -m <span class="token string">"add test.txt"</span><span class="token punctuation">[</span>master c6f2547<span class="token punctuation">]</span> add test.txt 1 <span class="token function">file</span> changed, 0 insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, 0 deletions<span class="token punctuation">(</span>-<span class="token punctuation">)</span> create mode 100644 test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p><pre><code>$ rm test.txt</code></pre><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add/rm &lt;file>..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git restore &lt;file>..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>        deleted:    test.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">rm</span> test.txt<span class="token function">rm</span> <span class="token string">'test.txt'</span>$ <span class="token function">git</span> commit -m <span class="token string">"rm test.txt"</span><span class="token punctuation">[</span>master 59826ca<span class="token punctuation">]</span> <span class="token function">rm</span> test.txt delete mode 100644 test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，文件就从版本库中被删除了。</p><p>小提示：先手动删除文件，然后使用<code>git rm &lt;file&gt;</code>和<code>git add&lt;file&gt;</code>效果是一样的。</p><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> restore test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li><p>初始化一个Git仓库，使用<code>git init</code>命令。</p></li><li><p>添加文件到Git仓库，分两步：</p><ol><li><p>使用命令<code>git add</code>，注意，可反复多次使用，添加多个文件；</p></li><li><p>使用命令<code>git commit -m</code>，完成。</p></li></ol></li></ul><ul><li><p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p></li><li><p>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p></li></ul><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><ul><li><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git restore &lt;file&gt;</code>。</p></li><li><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git restore --staged &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p></li><li><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p></li></ul><ul><li>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 教程 </tag>
            
            <tag> CLI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串流 istringstream 和 ostringstream 的用法</title>
      <link href="/zi-fu-chuan-liu-istringstream-he-ostringstream-de-yong-fa/"/>
      <url>/zi-fu-chuan-liu-istringstream-he-ostringstream-de-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>iostream 标准库支持内存中的输入／输出，只要将流与存储在程序内存中的 string 对象捆绑起来即可。此时，可使用 iostream 输入和输出操作符读写这个 string 对象。</p><p>标准库定义了三种类型的字符串流：</p><ul><li><p><code>istringstream</code>，由 istream 派生而来，提供<strong>读</strong> string 的功能。</p></li><li><p><code>ostringstream</code>，由 ostream 派生而来，提供<strong>写</strong> string 的功能。</p></li><li><p><code>stringstream</code>，由 iostream 派生而来，提供<strong>读写</strong> string 的功能。</p><p>要使用上述类，必须包含 <code>sstream</code> 头文件。</p></li></ul><p>与 fstream 类型一样，上述类型由 iostream 类型派生而来，这意味着 iostream 上所有的操作适用于 sstream 中的类型。sstream 类型除了继承的操作外，还各自定义了一个有 string 形参的构造函数，这个构造函数将 string 类型的实参复制给 stringstream 对象。对 stringstream 的读写操作实际上读写的就是该对象中的 string 对象。这些类还定义了名为 str 的成员，用来读取或设置 stringstream 对象所操纵的 string 值。</p><p>注意到尽管 fstream 和 sstream 共享相同的基类，但它们没有其他相互关系。特别是，stringstream 对象不使用open 和 close 函数，而 fstream 对象则不允许使用 str。</p><h2 id="2-stringstram常用操作"><a href="#2-stringstram常用操作" class="headerlink" title="2.stringstram常用操作"></a>2.stringstram常用操作</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 创建stringstream对象</span>stringstream stream<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建以s为副本的stringstream对象</span>string s <span class="token operator">=</span> <span class="token string">"deardeer.tech"</span><span class="token punctuation">;</span>stringstream <span class="token function">stream</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 返回一个string对象，值为当前stringstream对象的内容</span>stream<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 拷贝s的内容到stream中</span>stream<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-istringstream"><a href="#3-istringstream" class="headerlink" title="3.istringstream"></a>3.istringstream</h2><pre class="line-numbers language-cpp"><code class="language-cpp">istringstream <span class="token function">istrm</span><span class="token punctuation">(</span><span class="token string">"1 2 3 4 5 6 7 8 9 10"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>string word<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>istrm <span class="token operator">>></span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> word <span class="token operator">&lt;&lt;</span> <span class="token string">'|'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 运行结果：1|2|3|4|5|6|7|8|9|10|</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-ostringstream"><a href="#2-ostringstream" class="headerlink" title="2.ostringstream"></a>2.ostringstream</h2><pre class="line-numbers language-cpp"><code class="language-cpp">ostringstream ostrm<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 将10,9,8,7,..,1写入ostringstream</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ostrm <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出ostringstream的内容</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> ostrm<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 运行结果：10 9 8 7 6 5 4 3 2 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-简单应用"><a href="#4-简单应用" class="headerlink" title="4.简单应用"></a>4.简单应用</h4><h3 id="a-特殊读入"><a href="#a-特殊读入" class="headerlink" title="a.特殊读入"></a>a.特殊读入</h3><p>一般我们可以每次一个单词或每次一行的方式处理输入的程序。第一种程序用 string 输入操作符，而第二种则使用 getline 函数。然而，有些程序需要同时使用这两种方式：有些处理基于每行实现，而其他处理则要操纵每行中每个单词。这时候我们可用 stringstream 对象实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp">string sentence<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 以行为单位操作</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> sentence<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    istringstream <span class="token function">istrm</span><span class="token punctuation">(</span>sentence<span class="token punctuation">)</span><span class="token punctuation">;</span>    string word<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>istrm <span class="token operator">>></span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 以单词为单位操作</span>        cout <span class="token operator">&lt;&lt;</span> word <span class="token operator">&lt;&lt;</span> <span class="token string">"#"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输入：Hello everyone! This is an ostringstream example!</span><span class="token comment" spellcheck="true">// 输出：Hello#everyone!#This#is#an#ostringstream#example!#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="b-格式化读写、转换"><a href="#b-格式化读写、转换" class="headerlink" title="b.格式化读写、转换"></a>b.格式化读写、转换</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">77.77</span><span class="token punctuation">;</span>ostringstream ostrm<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 写入ostringstream</span>ostrm <span class="token operator">&lt;&lt;</span> <span class="token string">"integer: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" float: "</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> ostrm<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 此时ostrm内容为：integer: 7 float: 77.77</span><span class="token keyword">int</span> c<span class="token punctuation">;</span><span class="token keyword">double</span> d<span class="token punctuation">;</span>istringstream <span class="token function">istrm</span><span class="token punctuation">(</span>ostrm<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>string ts<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 从istringstream读出</span>istrm <span class="token operator">>></span> ts <span class="token operator">>></span> c <span class="token operator">>></span> ts <span class="token operator">>></span> d<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 运行结果：</span><span class="token comment" spellcheck="true">// integer: 7 float: 77.77</span><span class="token comment" spellcheck="true">// 7 77.77</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串流 </tag>
            
            <tag> stringstram </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ lower_bound() 和 upper_bound() 用法</title>
      <link href="/c-lower-bound-he-upper-bound-yong-fa/"/>
      <url>/c-lower-bound-he-upper-bound-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>​    </p><p><code>lower_bound()</code> 和 <code>upper_bound()</code> 包含在头文件<code>&lt;algorithm&gt;</code>中。</p><p><code>lower_bound()</code>和<code>upper_bound()</code>都是利用二分查找的方法在一个排好序的数组中进行查找的，数组排序默认从小到大。</p><h2 id="2-函数介绍"><a href="#2-函数介绍" class="headerlink" title="2.函数介绍"></a>2.函数介绍</h2><h3 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound()"></a>lower_bound()</h3><ul><li><p>default : <code>it lower_bound(it first, it last, const &amp;val);</code> (it 表示iterator)</p></li><li><p>custom : <code>it lower_bound(it first, it last, const &amp;val, compare cmp);</code></p><p>Returns an iterator pointing to the first element in the range [first,last) which does <strong>not compare less than val</strong>. 函数返回  [first,last) 区间中不小于val的元素的迭代器指针， 如果找不到返回last。</p></li></ul><h3 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound()"></a>upper_bound()</h3><ul><li><p>default : <code>it upper_bound(it first, it last, const &amp;val);</code> (it 表示iterator)</p></li><li><p>custom : <code>it upper_bound(it first, it last, const &amp;val, compare cmp);</code></p><p>Returns an iterator pointing to the first element in the range [first,last) which <strong>compares greater than val</strong>. 函数返回  [first,last) 区间中大于val的元素的迭代器指针，如果找不到返回last。</p></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> pos1 <span class="token operator">=</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">-</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pos2 <span class="token operator">=</span> <span class="token function">upper_bound</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">-</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pos1 : "</span> <span class="token operator">&lt;&lt;</span> pos1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pos1 : 2</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pos2 : "</span> <span class="token operator">&lt;&lt;</span> pos2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pos2 : 5</span><span class="token keyword">int</span> pos3 <span class="token operator">=</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pos4 <span class="token operator">=</span> <span class="token function">upper_bound</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">-</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pos3 : "</span> <span class="token operator">&lt;&lt;</span> pos3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pos3 : 0</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pos4 : "</span> <span class="token operator">&lt;&lt;</span> pos4 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pos4 : 6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以发现：</p><p><code>lower_bound()</code> 得到的结果表示：<code>val</code>在数组最<strong>早</strong>能插入到那个位置</p><p><code>upper_bound()</code>得到的结果表示：<code>val</code>在数组最<strong>晚</strong>能插入到那个位置</p><h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h3><p><code>lower_bound()</code> 和 <code>upper_bound()</code>查找的数组是默认是从小到大排序的，如果我们的数组是从大到小排序的该怎么办？</p><p>一个容易想到的解决办法是我们可以先将数组逆序，然后正常查找即可。</p><p>其实我们可以使用<code>lower_bound()</code> 和 <code>upper_bound()</code>的第四个参数<code>cmp</code>，我们可以这样写：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">></span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> pos5 <span class="token operator">=</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span> <span class="token operator">-</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pos6 <span class="token operator">=</span> <span class="token function">upper_bound</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span> <span class="token operator">-</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pos5 : "</span> <span class="token operator">&lt;&lt;</span> pos5 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pos3 : 4</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pos6 : "</span> <span class="token operator">&lt;&lt;</span> pos6 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pos4 : 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然我们也可以用<code>greater&lt;type&gt;()</code>代替 <code>cmp</code>，效果是一样的。</p><p>我们总结发现：</p><p>lower_bound() 在数组中找出 val的左边界， upper_bound() 在数组中找出val的右边界，而且结果正好符合[val)，左闭右开。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 库函数 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11 Lambda表达式</title>
      <link href="/c-11-lambda-biao-da-shi/"/>
      <url>/c-11-lambda-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/DswCnblog/p/5629165.html" target="_blank" rel="noopener">参考1</a></p><p><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=vs-2019" target="_blank" rel="noopener">参考2</a></p><p>C++11的一大亮点就是引入了Lambda表达式。利用Lambda表达式，可以方便的定义和创建匿名函数。对于C++这门语言来说来说，“Lambda表达式”或“匿名函数”这些概念听起来好像很深奥，但很多高级语言在很早以前就已经提供了Lambda表达式的功能，如C#，<a href="http://lib.csdn.net/base/11" target="_blank" rel="noopener">Python</a>等。今天，我们就来简单介绍一下C++中Lambda表达式的简单使用。</p><h2 id="声明Lambda表达式"><a href="#声明Lambda表达式" class="headerlink" title="声明Lambda表达式"></a><strong>声明Lambda表达式</strong></h2><p>Lambda表达式完整的声明格式如下：</p><pre><code>[capture list] (params list) mutable exception-&gt; return type { function body }</code></pre><p>各项具体含义如下</p><ol><li>capture list：捕获外部变量列表</li><li>params list：形参列表</li><li>mutable指示符：用来说用是否可以修改捕获的变量</li><li>exception：异常设定</li><li>return type：返回类型</li><li>function body：函数体</li></ol><p>此图显示了 lambda 的组成部分：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20200917175518.png" alt="lambda 表达式的结构化元素"></p><ol><li><em>捕获子句</em>（在 c + + 规范中也称为<em>lambda 引导</em>）。</li><li><em>参数列表</em>可有可无. （也称为<em>lambda 声明符</em>）</li><li><em>可变规范</em>可有可无.</li><li><em>异常规范</em>可有可无.</li><li><em>尾随-返回类型</em>可有可无.</li><li><em>lambda 体</em>。</li></ol><p>此外，我们还可以省略其中的某些成分来声明“不完整”的Lambda表达式，常见的有以下几种：</p><table><thead><tr><th>序号</th><th>格式</th></tr></thead><tbody><tr><td>1</td><td>[capture list] (params list) -&gt; return type {function body}</td></tr><tr><td>2</td><td>[capture list] (params list) {function body}</td></tr><tr><td>3</td><td>[capture list] {function body}</td></tr></tbody></table><p>其中：</p><ul><li><p>格式1声明了const类型的表达式，这种类型的表达式不能修改捕获列表中的值。</p></li><li><p>格式2省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型： （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定； （2）：如果function body中没有return语句，则返回值为void类型。</p></li><li><p>格式3中省略了参数列表，类似普通函数中的无参函数。</p><p>讲了这么多，我们还没有看到Lambda表达式的庐山真面目，下面我们就举一个实例。</p></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span>  a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> myvec<span class="token punctuation">{</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">lbvec</span><span class="token punctuation">(</span>myvec<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>myvec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> myvec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 旧式做法</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"predicate function:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> it <span class="token operator">:</span> myvec<span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> it <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>lbvec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lbvec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">bool</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Lambda表达式</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lambda expression:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> it <span class="token operator">:</span> lbvec<span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> it <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在C++11之前，我们使用STL的sort函数，需要提供一个谓词函数。如果使用C++11的Lambda表达式，我们只需要传入一个匿名函数即可，方便简洁，而且代码的可读性也比旧式的做法好多了。</p><p>下面，我们就重点介绍一下Lambda表达式各项的具体用法。</p><h2 id="捕获外部变量"><a href="#捕获外部变量" class="headerlink" title="捕获外部变量"></a><strong>捕获外部变量</strong></h2><p>Lambda表达式可以使用其可见范围内的外部变量，但必须明确声明（明确声明哪些外部变量可以被该Lambda表达式使用）。那么，在哪里指定这些外部变量呢？Lambda表达式通过在最前面的方括号[]来明确指明其内部可以访问的外部变量，这一过程也称过Lambda表达式“捕获”了外部变量。</p><p>我们通过一个例子来直观地说明一下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：123</span>    <span class="token comment" spellcheck="true">//或通过“函数体”后面的‘()’传入参数</span>    <span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这个例子先声明了一个整型变量a，然后再创建Lambda表达式，该表达式“捕获”了a变量，这样在Lambda表达式函数体中就可以获得该变量的值。</p><p>类似参数传递方式（值传递、引入传递、指针传递），在Lambda表达式中，外部变量的捕获方式也有值捕获、引用捕获、隐式捕获。</p><h3 id="1、值捕获"><a href="#1、值捕获" class="headerlink" title="1、值捕获"></a><strong>1、值捕获</strong></h3><p>值捕获和参数传递中的值传递类似，被捕获的变量的值在Lambda表达式创建时通过值拷贝的方式传入，因此随后对该变量的修改不会影响影响Lambda表达式中的值。</p><p>示例如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>     a <span class="token operator">=</span> <span class="token number">321</span><span class="token punctuation">;</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：123</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要注意的是，如果以传值方式捕获外部变量，则在Lambda表达式函数体中不能修改该外部变量的值。</p><h3 id="2、引用捕获"><a href="#2、引用捕获" class="headerlink" title="2、引用捕获"></a><strong>2、引用捕获</strong></h3><p>使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符&amp;。如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>a<span class="token punctuation">]</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>     a <span class="token operator">=</span> <span class="token number">321</span><span class="token punctuation">;</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：321</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从示例中可以看出，引用捕获的变量使用的实际上就是该引用所绑定的对象。</p><h3 id="3、隐式捕获"><a href="#3、隐式捕获" class="headerlink" title="3、隐式捕获"></a><strong>3、隐式捕获</strong></h3><p>上面的值捕获和引用捕获都需要我们在捕获列表中显示列出Lambda表达式中使用的外部变量。除此之外，我们还可以让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获。隐式捕获有两种方式，分别是[=]和[&amp;]。[=]表示以值捕获的方式捕获外部变量，[&amp;]表示以引用捕获的方式捕获外部变量。</p><p>隐式值捕获示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 值捕获</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：123</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>隐式引用捕获示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 引用捕获</span>    a <span class="token operator">=</span> <span class="token number">321</span><span class="token punctuation">;</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：321</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、混合方式"><a href="#4、混合方式" class="headerlink" title="4、混合方式"></a><strong>4、混合方式</strong></h3><p>上面的例子，要么是值捕获，要么是引用捕获，Lambda表达式还支持混合的方式捕获外部变量，这种方式主要是以上几种捕获方式的组合使用。</p><p>到这里，我们来总结一下：C++11中的Lambda表达式捕获外部变量主要有以下形式：</p><table><thead><tr><th>捕获形式</th><th>说明</th></tr></thead><tbody><tr><td>[]</td><td>不捕获任何外部变量</td></tr><tr><td>[变量名, …]</td><td>默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td></tr><tr><td>[this]</td><td>以值的形式捕获this指针</td></tr><tr><td>[=]</td><td>以值的形式捕获所有外部变量</td></tr><tr><td>[&amp;]</td><td>以引用形式捕获所有外部变量</td></tr><tr><td>[=, &amp;x]</td><td>变量x以引用形式捕获，其余变量以传值形式捕获</td></tr><tr><td>[&amp;, x]</td><td>变量x以值的形式捕获，其余变量以引用形式捕获</td></tr></tbody></table><h2 id="修改捕获变量"><a href="#修改捕获变量" class="headerlink" title="修改捕获变量"></a><strong>修改捕获变量</strong></h2><p>前面我们提到过，在Lambda表达式中，如果以传值方式捕获外部变量，则函数体中不能修改该外部变量，否则会引发编译错误。那么有没有办法可以修改值捕获的外部变量呢？这是就需要使用mutable关键字，该关键字用以说明表达式体内的代码可以修改值捕获的变量，示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>a<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不会报错</span>    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：123</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：124</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Lambda表达式的参数"><a href="#Lambda表达式的参数" class="headerlink" title="Lambda表达式的参数"></a><strong>Lambda表达式的参数</strong></h2><p>Lambda表达式的参数和普通函数的参数类似，那么这里为什么还要拿出来说一下呢？原因是在Lambda表达式中传递参数还有一些限制，主要有以下几点：</p><ol><li>参数列表中不能有默认参数</li><li>不支持可变参数</li><li>所有参数必须有参数名</li></ol><p>常用举例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">{</span>　　　　 <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"m:"</span> <span class="token operator">&lt;&lt;</span> m <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>            　　<span class="token comment" spellcheck="true">//输出m:16</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"n:"</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//输出n:9</span>        <span class="token keyword">auto</span> gFunc <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> lFunc <span class="token operator">=</span> <span class="token function">gFunc</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">lFunc</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">auto</span> hFunc <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">&amp;</span> f<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token function">hFunc</span><span class="token punctuation">(</span><span class="token function">gFunc</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">111</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">222</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span> <span class="token punctuation">{</span>             a <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span> b <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">;</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a:"</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" b:"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a:"</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" b:"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        a <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> func2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">]</span> <span class="token punctuation">{</span>             a <span class="token operator">=</span> <span class="token number">444</span><span class="token punctuation">;</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a:"</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" b:"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> func3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">;</span>    　　　　　　 std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">></span> f_display_42 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">print_num</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">f_display_42</span><span class="token punctuation">(</span><span class="token number">44</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
            <tag> Lambda表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ rand 与 srand 的用法</title>
      <link href="/c-rand-yu-srand-de-yong-fa/"/>
      <url>/c-rand-yu-srand-de-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="0-简介"><a href="#0-简介" class="headerlink" title="0.简介"></a>0.简介</h2><p>计算机的随机数都是由伪随机数，即是由小M多项式序列生成的，其中产生每个小序列都有一个初始值，即随机种子。（注意： 小M多项式序列的周期是65535，即每次利用一个随机种子生成的随机数的周期是65535，当你取得65535个随机数后它们又重复出现了。）</p><p>我们知道 rand() 函数可以用来产生随机数，但是这不是真正意义上的随机数，是一个伪随机数，是根据一个数（我们可以称它为种子）为基准以某个递推公式推算出来的一系列数，当这系列数很大的时候，就符合正态公布，从而相当于产生了随机数，但这不是真正的随机数，当计算机正常开机后，这个种子的值是定了的，除非你破坏了系统。</p><h2 id="1-rand"><a href="#1-rand" class="headerlink" title="1.rand()"></a>1.rand()</h2><p>功能:</p><p>随机数发生器</p><p>用法:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所在头文件:</p><pre class="line-numbers language-cpp"><code class="language-cpp">stdlib<span class="token punctuation">.</span>h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>rand() 的内部实现是用线性同余法做的，它不是真的随机数，因其周期特别长，故在一定的范围里可看成是随机的。</p><p>rand() 返回一随机数值的范围在 0 至 RAND_MAX 间。RAND_MAX 的范围最少是在 32767 之间(int)。用 unsigned int 双字节是 65535，四字节是 4294967295 的整数范围。0~RAND_MAX 每个数字被选中的机率是相同的。</p><p>用户未设定随机数种子时，系统默认的随机数种子为 1。</p><p>rand() 产生的是伪随机数字，每次执行时是相同的; 若要不同, 用函数 srand() 初始化它。</p><h2 id="2-srand"><a href="#2-srand" class="headerlink" title="2.srand()"></a>2.srand()</h2><p>功能:</p><p>初始化随机数发生器</p><p>用法:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">srand</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> seed<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所在头文件:</p><pre class="line-numbers language-cpp"><code class="language-cpp">stdlib<span class="token punctuation">.</span>h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>srand() 用来设置 rand() 产生随机数时的随机数种子。参数 seed 必须是个整数，如果每次 seed 都设相同值，rand() 所产生的随机数值每次就会一样。</p><h2 id="3-使用当前时钟作为随机数种子"><a href="#3-使用当前时钟作为随机数种子" class="headerlink" title="3.使用当前时钟作为随机数种子"></a>3.使用当前时钟作为随机数种子</h2><p>rand() 产生的随机数在每次运行的时候都是与上一次相同的。若要不同, 用函数 srand() 初始化它。可以利用 srand((unsigned int)(time(NULL)) 的方法，产生不同的随机数种子，因为每一次运行程序的时间是不同的。</p><h2 id="4-产生随机数的用法"><a href="#4-产生随机数的用法" class="headerlink" title="4.产生随机数的用法"></a>4.产生随机数的用法</h2><ul><li>1) 给srand()提供一个种子，它是一个unsigned int类型；</li><li>2) 调用rand()，它会根据提供给srand()的种子值返回一个随机数(在0到RAND_MAX之间)；</li><li>3) 根据需要多次调用rand()，从而不间断地得到新的随机数；</li><li>4) 无论什么时候，都可以给srand()提供一个新的种子，从而进一步”随机化”rand()的输出结果。</li></ul><p>0~RAND_MAX 之间的随机数程序</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span> </span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span> <span class="token punctuation">)</span>                 cout <span class="token operator">&lt;&lt;</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'/t'</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-产生一定范围随机数的通用表示公式"><a href="#5-产生一定范围随机数的通用表示公式" class="headerlink" title="5.产生一定范围随机数的通用表示公式"></a>5.产生一定范围随机数的通用表示公式</h2><p>要取得 [a,b) 的随机整数，使用 (rand() % (b-a))+ a;</p><p>要取得 [a,b] 的随机整数，使用 (rand() % (b-a+1))+ a;</p><p>要取得 (a,b] 的随机整数，使用 (rand() % (b-a))+ a + 1;</p><p>通用公式: a + rand() % n；其中的 a 是起始值，n 是整数的范围。</p><p>要取得 a 到 b 之间的随机整数，另一种表示：a + (int)b * rand() / (RAND_MAX + 1)。</p><p>要取得 0～1 之间的浮点数，可以使用 rand() / double(RAND_MAX)。</p><p><code>原文链接：https://www.runoob.com/w3cnote/cpp-rand-srand.html</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 库函数 </tag>
            
            <tag> 随机数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找模板总结</title>
      <link href="/er-fen-cha-zhao-mo-ban/"/>
      <url>/er-fen-cha-zhao-mo-ban/</url>
      
        <content type="html"><![CDATA[<p><strong>三种二分查找场景：</strong></p><ul><li>寻找一个数</li><li>寻找左侧边界</li><li>寻找右侧边界</li></ul><h2 id="零、二分查找框架"><a href="#零、二分查找框架" class="headerlink" title="零、二分查找框架"></a>零、二分查找框架</h2><p><code>l</code> 为左侧边界，<code>r</code> 为右侧边界，<code>nums</code>为查找范围，<code>target</code> 为目标数。</p><p>具体细节再根据需要更改。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            r <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> l <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一、寻找一个数"><a href="#一、寻找一个数" class="headerlink" title="一、寻找一个数"></a>一、寻找一个数</h2><p><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></p><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><pre><code>输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4</code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> m<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、寻找左侧边界"><a href="#二、寻找左侧边界" class="headerlink" title="二、寻找左侧边界"></a>二、寻找左侧边界</h2><p>与上面题目不同的是，升序数组中存在重复的元素，我们需要返回<code>target</code>第一次出现的位置，若没有则返回-<code>1</code>。</p><pre><code>输入: nums = [1,2,3,3,3,6,7], target = 3输出: 2解释: 3 第一次出现在 nums 中的下标为 2</code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">leftBound</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// r = n - 1</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// ！l &lt;= r</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 锁定左边界，收紧右边界</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// while 中止情况为 l = r + 1</span>        <span class="token comment" spellcheck="true">// 根据 l 判断查找情况</span>        <span class="token keyword">return</span> l <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> l <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、寻找右侧边界"><a href="#三、寻找右侧边界" class="headerlink" title="三、寻找右侧边界"></a>三、寻找右侧边界</h2><p>这次的情况同样是存在重复的元素，我们需要返回<code>target</code>最后出现的位置，若没有则返回-<code>1</code>。</p><pre class="line-numbers language-cpp"><code class="language-cpp">输入<span class="token operator">:</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token number">3</span>输出<span class="token operator">:</span> <span class="token number">4</span>解释<span class="token operator">:</span> <span class="token number">3</span> 最后出现在 nums 中的下标为 <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">rightBound</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ! r = n -1</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// ！l &lt;= r</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 锁定右边界，收紧左边界</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// while 中止情况为 l = r + 1</span>        <span class="token comment" spellcheck="true">// 根据 r 判断查找情况</span>        <span class="token keyword">return</span> r <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> r <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h2><p>本文的二分模板基于左闭右闭的搜索区间，即<code>[l, r]</code> ，实际运用中我们也可以采用一般的左闭右开的搜索区间，即<code>[l, r)</code>，我们只需要根据查找情况对对细节部分进行修改：</p><p><strong>寻找左侧边界：</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 参考</span><span class="token keyword">int</span> <span class="token function">left_bound</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 注意</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            right <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            right <span class="token operator">=</span> mid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 类似之前算法的处理方式</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> left <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>寻找右侧边界：</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 参考</span><span class="token keyword">int</span> <span class="token function">right_bound</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            right <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> <span class="token punctuation">(</span>left<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0-1 Knapsack Problem</title>
      <link href="/0-1-knapsack-problem/"/>
      <url>/0-1-knapsack-problem/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://practice.geeksforgeeks.org/problems/0-1-knapsack-problem/0" target="_blank" rel="noopener"><strong>0 - 1 Knapsack Problem</strong></a></p><h3 id="描述："><a href="#描述：" class="headerlink" title="描述："></a><strong>描述：</strong></h3><p>给你<strong>N个</strong>物品的重量和价值，将这些物品放入容量为<strong>W</strong>的背包中，以获取背包中的最大总价值。请注意，<strong>每个项目</strong>只有<strong>一个数量</strong>。<br>换句话说，给定两个整数数组<strong>val [0..N-1]</strong>和<strong>wt [0..N-1]</strong>，它们分别表示与<strong>N个</strong>物品的重量和价值。还要给定代表背包容量的整数<strong>W</strong>，找出<strong>val []</strong>的最大值子集，以使该子集的权重之和小于或等于<strong>W。</strong>你不能破坏某个物品（比如把物品拆分），<strong>只能选择它，或者不要选择它（0-1属性）</strong>。</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a><strong>输入：</strong></h3><p>的第一行包含一个整数<strong>T，</strong>表示测试用例的数量。然后是 <strong>T</strong>测试用例。每个测试用例包含四行。<br>第一行由<strong>N</strong>个项目组成。<br>第二行包含<strong>W</strong>，即背包的最大容量。<br>在第三行中， <strong>N个</strong>空格分隔的正整数表示<strong>N个</strong>物品的价值，<br>在第四行中，<strong>N个</strong>空格分隔的正整数表示相应物品的重量。</p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a><strong>输出：</strong></h3><p>对于每个测试用例，在新一行中，输出在给定条件下可以获得的<strong>背包最大价值</strong>。</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><h3 id="明确问题的状态和选择"><a href="#明确问题的状态和选择" class="headerlink" title="明确问题的状态和选择."></a>明确问题的状态和选择.</h3><p>分析题目可以发现问题的状态有两个，背包容量和可选择的物品；对于每个物品，我们在选择时有两种方案：<strong>装进背包</strong>或者<strong>不装进背包</strong>，这也是为什么叫做0-1背包问题。</p><h3 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h3><p>刚才分析出来问题的状态有两个，因此需要一个二维数组，一维表示可选的物品范围，另一维表示背包的容量。<strong><code>dp[i][j]</code>的定义如下：对于前<code>i</code>个物品，当前背包的容量为<code>j</code>，这种情况下可以装的最大价值是<code>dp[i][j]</code>。</strong></p><p>这样我们最终想要的答案就是<code>dp[N][W]</code>。</p><p>基础状态：<code>dp[..][j] = 0</code>， 因为可选的物品为空，即背包什么都没有装，价值为零；<code>dp[i][..] = 0</code>，因为背包的容量为零，什么也装不了。</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>回顾刚才的分析，状态的改变有两个选择：</p><p>对与第i个商品，①不装入背包，那么背包的最大价值<code>dp[i][j]</code>显然是继承<code>dp[i-1][j]</code>，背包的容量和价值都不变。②装入背包，那么背包的最大价值应该是前i-1个物品的最大价值加上第i个商品的价值，换句话说，我们的前提是<strong>装第<code>i</code>个物品</strong>，也就是在剩余重量<code>w-wt[i-1]</code>限制下能装的最大价值，加上第<code>i</code>个物品的价值<code>val[i-1]</code>，即<code>dp[i][j] = dp[i-1][j-wt[i-1]]+val[i-1]</code>。 </p><p>注意：物品的价值和重量数组下标从0开始，即wt[i-1]和al[i-1]分别对应第i个物品的重量和价值。</p><p>综合一下我们的状态转移方程就是：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200725130553.png" alt="状态转移方程"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cmath></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> t<span class="token punctuation">;</span>    cin<span class="token operator">>></span>t<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>w<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cin <span class="token operator">>></span> n <span class="token operator">>></span> w<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">val</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">wt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            cin <span class="token operator">>></span> val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            cin <span class="token operator">>></span> wt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>w<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> w<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>wt<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>wt<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> val<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复杂度分析：</p><ul><li><p>时间复杂度：O(N*W)</p><p>N代表物品的数量，W代表背包的容量。</p></li><li><p>空间复杂度：O(N*W)</p><p>使用一个N*W的二位数组。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 简单 </tag>
            
            <tag> geeksforgeeks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的正无穷和负无穷</title>
      <link href="/c-zhong-de-zheng-wu-qiong-he-fu-wu-qiong/"/>
      <url>/c-zhong-de-zheng-wu-qiong-he-fu-wu-qiong/</url>
      
        <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>如果是<strong>int</strong>，可以用<code>INT_MAX</code>表示正无穷，<code>INT_MIN</code>表示负无穷，需要包含<code>limits.h</code>。</p><p>如果是<strong>double</strong>，可以用<code>DBL_MAX</code>表示正无穷，<code>-DBL_MAX</code>表示负无穷(注意不是DBL_MIN)，需要包含<code>float.h</code></p><p>这里用Dev C++查出：</p><ul><li>INT_MAX = 2147483647 </li><li>INT_MIN = -2147483648 </li><li>DBL_MAX = 1.79769e+308 </li><li>-DBL_MAX = -1.79769e+308</li></ul><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200724221631.png" alt="测试图"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>好奇的扒了下Dev C++的limits.h和floa.h，发现里面还定义了不少其他的量：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200724222051.png" alt="limits.h"></p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200724222501.png" alt="flaot.h"></p><p>看来头文件里还是有很多秘密啊！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无穷大 </tag>
            
            <tag> 头文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode300. Longest Increasing Subsequence </title>
      <link href="/leetcode300-longest-increasing-subsequence/"/>
      <url>/leetcode300-longest-increasing-subsequence/</url>
      
        <content type="html"><![CDATA[<h2 id="题目：300-最长上升子序列"><a href="#题目：300-最长上升子序列" class="headerlink" title="题目：300. 最长上升子序列"></a>题目：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><p>输入: <code>[10,9,2,5,3,7,101,18]</code><br>输出: <code>4</code><br>解释: 最长的上升子序列是 <code>[2,3,7,101]</code>，它的长度是 <code>4</code>。</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>值得注意的是，要区分子序列和子串的概念，子串要求连续，而子序列没有这个要求。</p><p>我们定义dp数组为<code>dp[i]</code>，它表示的含义是以第<code>i</code>个数即<code>nums[i]</code>结尾的最长上升子序列的长度。</p><p>对于每一个子序列，显然它的最小长度为<code>1</code>即包含自身一个元素，所以我们的<strong>基础状态</strong><code>dp[i] = 1</code>。</p><p>接下来考虑状态转移方程：</p><p>假设我们求出了<code>dp[i-1]</code>，我们该如何求<code>dp[i]</code>呢？</p><p>既然要求是一个上升的子序列，那么必然需要从<code>nums[0]</code>到<code>nums[i-1]</code>找比<code>nums[i]</code>小的数作为子序列的前一项，从而构造出一个较长的子序列;想要达到最长子序列的目的，我们需要考虑所有可能的子序列，然后选出长度最大的即可。</p><p>我们可以写出：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200720162000.png" alt="状态转移方程"></p><p>求出以每个元素为结尾的最大上升子序列后，再遍历求出求大的子序列长度即为整个无序数组的最长上升子序列的长度。</p><p>代码为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//dp数组全部初始化为1</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//求出最大的序列长度</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token operator">:</span>dp<span class="token punctuation">)</span><span class="token punctuation">{</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的解法算法时间复杂度为<strong>O(n^2)</strong>，做到这里已经可以了，但实际上时间复杂度还可降到<strong>O(nlogn)</strong>，也就是下面扩展介绍的二分解法。</p><h2 id="二分查找解法"><a href="#二分查找解法" class="headerlink" title="二分查找解法"></a>二分查找解法</h2><p>明眼看，总感觉二分解法和这道题扯不上关系，其实有一种纸牌游戏叫做patience game，它的玩法与最长上升子序列有关系，以这种游戏为名还衍生出了一种排序算法：patience sorting。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200720164400.png" alt="patience sorting"></p><p>这个纸牌游戏也叫纸牌接龙，相信大家都玩过。</p><p>大佬的介绍：</p><p>首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200720165821.webp" alt="poker1"></p><p><strong>处理这些扑克牌要遵循以下规则</strong>：</p><p>只能把点数小的牌压到点数比它大的牌上；如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去；如果当前牌有多个堆可供选择，则选择最左边的那一堆放置。</p><p>比如说上述的扑克牌最终会被分成这样 5 堆（我们认为纸牌 A 的牌面是最大的，纸牌 2 的牌面是最小的）。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200720165827.webp" alt="poker2"></p><p>为什么遇到多个可选择堆的时候要放到最左边的堆上呢？稍加观察可以发现，<strong>这样可以保证牌堆顶的牌有序</strong>（2, 4, 7, 8, Q）。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200720165832.webp" alt="poker3"></p><p>按照上述规则执行，可以算出最长递增子序列，牌的堆数就是最长递增子序列的长度，<strong>因为如果从每堆拿出一张牌，就可以形成一个递增子序列。又因为每堆牌的值是递减的，所以这个递增子序列是最长的。</strong></p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200720165903.webp" alt="LIS"></p><p>我们只要把处理扑克牌的过程编程写出来即可。每次处理一张扑克牌不是要找一个合适的牌堆顶来放吗，牌堆顶的牌不是<strong>有序</strong>吗，这就能用到二分查找了：用二分查找来搜索当前牌应放置的位置，从而使算法时间复杂度降到<code>O(nlogn)</code>。</p><p>代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//cards记录每堆牌的最下面的牌</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">cards</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//牌堆数初始为0</span>        <span class="token keyword">int</span> piles <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//开始摆牌</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//要处理的牌</span>            <span class="token keyword">int</span> poker <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> piles<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cards<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> poker<span class="token punctuation">)</span><span class="token punctuation">{</span>                    l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cards<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> poker<span class="token punctuation">)</span><span class="token punctuation">{</span>                    r <span class="token operator">=</span> mid<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//如果没找到合适牌堆，新建牌堆</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">==</span> piles<span class="token punctuation">)</span> piles<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//更新cards</span>            cards<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> poker<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//牌堆数即为最长公共子序列长度</span>        <span class="token keyword">return</span> piles<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode322. Coin Change</title>
      <link href="/leetcode322-coin-change/"/>
      <url>/leetcode322-coin-change/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">LeetCode322. Coin Change</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>1、base case</strong></p><p>当目标金额<code>amount</code> 为0时，不需要任何硬币即可凑出。</p><p><strong>2、状态</strong></p><p>状态是会变化的量，这里显然有目标金额<code>amount</code>需要不断减少，向base case靠近，所以<code>amount</code>是唯一的状态。</p><p><strong>3、选择</strong></p><p>选择是导致状态变化的行为。我们需要对所有的硬币做尝试，选出能使硬币个数最少的方案。</p><p><strong>4、定义dp函数/数组</strong></p><p>这里自顶向下的解法定义为：</p><p><code>dp(n) = x</code>: 表示目标金额为n时，至少需要x个硬才币可以凑出。</p><p>由此写出状态转移方程：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200719161546.png" alt="状态转移方程"></p><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">dp</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> memo<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>amount<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>amount<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//已经计算过，直接返回</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//未计算过则计算</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> sub <span class="token operator">=</span> <span class="token function">dp</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span>amount <span class="token operator">-</span> coin <span class="token punctuation">,</span>memo<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sub<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>sub<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//更新memo</span>        memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>res<span class="token operator">==</span>INT_MAX<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> res<span class="token punctuation">;</span>        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>amount<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//memo[n] = x ：amount= n的钱至少需要x个硬币凑出来</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">memo</span><span class="token punctuation">(</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">dp</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里设的备忘录memo。</p><p>递归算法的时间复杂度为 <strong>子问题总数 x 每个子问题的时间</strong>。</p><p>子问题总数不超过金额数n，即子问题数目O(n)，处理一个子问题需要一个for循环，设时间O(k)。所以总时间复杂度为O(n*k)。</p><h2 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>amount<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//硬币面额为整数，即最小为1</span>        <span class="token comment" spellcheck="true">//所以硬币个数dp[?]最大不会超过目标金额数</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//base case</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> coin<span class="token operator">:</span>coins<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">-</span>coin<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>coin<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>dp</code> 数组的定义：当目标金额为 <code>i</code> 时，至少需要 <code>dp[i]</code> 枚硬币凑出。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows更新npm和nodejs</title>
      <link href="/windows-geng-xin-npm-he-nodejs/"/>
      <url>/windows-geng-xin-npm-he-nodejs/</url>
      
        <content type="html"><![CDATA[<h2 id="查看当前npm和nodejs版本"><a href="#查看当前npm和nodejs版本" class="headerlink" title="查看当前npm和nodejs版本"></a>查看当前npm和nodejs版本</h2><pre class="line-numbers language-npm"><code class="language-npm">npm -vnode -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200718221823.png" alt="查看npm和node版本"></p><p>我更新前的版本，这里放出来做参考。</p><h2 id="升级npm版本"><a href="#升级npm版本" class="headerlink" title="升级npm版本"></a>升级npm版本</h2><pre class="line-numbers language-npm"><code class="language-npm">npm install -g npm  或者 npm install npm -g    #升级到最新版本npm install npm@latest -g    #升级到最新版本npm install npm@4.1.2 -g    #升级到指定版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200718220332.png" alt="npm升级到最新版本"></p><p>可以看到我升级前是v5.6.0，在执行升级到最新版本命令<code>npm install npm@latest -g</code>后变为v6.14.6。</p><h2 id="升级nodejs版本"><a href="#升级nodejs版本" class="headerlink" title="升级nodejs版本"></a>升级nodejs版本</h2><p>在<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">node官网</a>下载新版本node的 msi 安装包，然后覆盖安装之前的版本来完成更新操作。</p><p>注意安装路径要和之前的位置一致，如果不知道之前安装在哪个位置可以用命令<code>where node</code></p><pre class="line-numbers language-npm"><code class="language-npm">where node #查看nodejs安装位置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200718221458.png" alt="查看node安装位置"></p><p>node官网下载安装完新版本nodejs后，使用命令<code>node -v</code>查看当前node版本</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200718221725.png" alt="查看当前node版本"></p><p>到这里npm和node就都更新升级完毕了。</p><p><strong>⚠踩坑警告</strong></p><p>我猜测在这步之前大家应该都没有问题（反正我是）。我按照网上广为流传的升级node方法：</p><p>使用<code>npm install -g n --force</code>的方法，安装 n 模块，node版本管理工具。<br>安装n模块：<code>npm install -g n</code>，执行后会报错</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200718222326.png" alt="安装n模块"></p><p>尝试使用强制安装命令：<code>npm install -g n --force</code>，好像成功了？？？</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200718223149.png" alt="强制安装n模块"></p><p>以为马上就要大功告成了，but！</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200718223151.png" alt="失败图"></p><p>这是什么原因呢，明明安装上了还没法用！</p><p>网上查到<a href="https://www.npmjs.com/package/n" target="_blank" rel="noopener">n模块官方</a>提示：</p><p> <code>Note: n is not supported natively on Windows.</code> Windows自然情况下是不支持n模块的。</p><p> 所以出现了上面虽然强制安装了，但是并不支持使用的情况。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> nodejs </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git设置和取消代理</title>
      <link href="/git-she-zhi-he-qu-xiao-dai-li/"/>
      <url>/git-she-zhi-he-qu-xiao-dai-li/</url>
      
        <content type="html"><![CDATA[<h2 id="1、git设置代理"><a href="#1、git设置代理" class="headerlink" title="1、git设置代理"></a>1、git设置代理</h2><pre class="line-numbers language-git"><code class="language-git">git config --global https.proxy http://127.0.0.1:1088<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-git"><code class="language-git">git config --global https.proxy https://127.0.0.1:1088<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-git"><code class="language-git">git config --global https.proxy socks5://127.0.0.1:1088<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-git"><code class="language-git"><span class="token comment" spellcheck="true">#只对github.com</span>git config --global http.https://github.com.proxy socks5://127.0.0.1:1088<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>端口号替换成你自己的就行了。</p><h2 id="2、git取消代理"><a href="#2、git取消代理" class="headerlink" title="2、git取消代理"></a>2、git取消代理</h2><pre class="line-numbers language-git"><code class="language-git">git config --global --unset http.proxy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-git"><code class="language-git">git config --global --unset https.proxy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-git"><code class="language-git"><span class="token comment" spellcheck="true">#取消代理github.com</span>git config --global --unset http.https://github.com.proxy)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参考：<strong><a href="https://gist.github.com/laispace/666dd7b27e9116faece6" target="_blank" rel="noopener">git 设置和取消代理</a></strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> proxy </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode509.Fibonacci Number</title>
      <link href="/leetcode509.fibonacci-number/"/>
      <url>/leetcode509.fibonacci-number/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">LeetCode509.Fibonacci Number</a>  </p><h2 id="1、暴力递归"><a href="#1、暴力递归" class="headerlink" title="1、暴力递归"></a>1、暴力递归</h2><p>斐波那契数列的性质：</p><p><code>f1 = f2 = 1</code> </p><p><code>fn = fn-1 - fn-2</code></p><p>从这个性质我们可以写出<strong>状态转移方程</strong>为：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200717163705.png" alt=""></p><p>很容易我们写出代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">||</span> N<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>N<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>N<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种写法很好想出，但算法时间复杂度非常高，指数级别，为<strong>O(2^N)</strong>。</p><p>原因是在递归的求解过程中有很多子问题被重复计算，这造成巨大的时间花费，使得算法变得十分低效。</p><h2 id="2、带备忘录的记忆化递归"><a href="#2、带备忘录的记忆化递归" class="headerlink" title="2、带备忘录的记忆化递归"></a>2、带备忘录的记忆化递归</h2><p>上一个解法提到提高解题效率的关键是如何消除子问题被重复计算。知道了这点，我们可以采用记<strong>备忘录</strong>的形式，每次求解子问题时，先不要着急计算，在备忘录中查询有无此子问题的答案，有的话直接返回结果；没有的话再递归求解子问题，同时将求解出的子问题答案记录在备忘录中。</p><p>这里使用一个vector数组当<strong>备忘录</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> memo<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果memo[N]未计算过则计算，否则直接返回</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>memo<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>         memo<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">calc</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span>N<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">calc</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span>N<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> memo<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">||</span> N<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//memo 数组做备忘录</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">memo</span><span class="token punctuation">(</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//base case</span>    memo<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> memo<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">calc</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了memo备忘录存储每个子问题的计算结果，每次遇到相同子问题计算时直接查表即可。这样一来算法的时间复杂度大大降低了，为<strong>O(N)</strong>，算法的空间复杂度为<strong>O(N)</strong>。这在理论上已经达到了和动态规划的迭代解法一样的效率。</p><h2 id="3、自底向上的迭代法"><a href="#3、自底向上的迭代法" class="headerlink" title="3、自底向上的迭代法"></a>3、自底向上的迭代法</h2><p>可以发现刚才的两种解法都是考虑<strong>自上而下的递归式解法</strong>，即我们从结果的最终态出发，向问题的基础状态靠近，从而求解出答案。实际上我们还可以从基础状态出发，通过迭代向上求解，这样的方法叫<strong>自底向上的迭代法</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">||</span> N<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//memo 数组做备忘录</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">memo</span><span class="token punctuation">(</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    memo<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> memo<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> memo<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> memo<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> memo<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>理论上，这种自底向上的迭代解法和自上而下的递归解法在时间复杂度方便是一样的，都是<strong>O(N)</strong>，但实际运行中，递归解法涉及较多的函数调用等耗费时间的操作，同样的问题规模可能要消耗稍微多一点时间。</p><p>一般来说，递归式的解法思路清晰，容易理解，迭代式的解法要求细节缜密，使用起来稍微复杂点，两者各有千秋。</p><h2 id="4、优化"><a href="#4、优化" class="headerlink" title="4、优化"></a>4、优化</h2><p>实际上，由斐波那契数的状态转移方程，我们可以发现每次求解的<strong>当前状态只与前两个状态有关系</strong>，即我们并不需要一整个备忘录表来存子问题的结果，只需要记住当前问题的前两个子问题结果。我们可以定义两个变量，每次利用这两个变量求出当前子问题的答案，再更新这两个变量，通过迭代获得问题的最终答案。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">||</span> N<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//f1,f2存储前两个状态，res记录结果</span>    <span class="token keyword">int</span> f1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> f2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//根据前两个状态，计算当前状态值</span>        res <span class="token operator">=</span> f1 <span class="token operator">+</span> f2<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//更新前两个状态</span>        f1 <span class="token operator">=</span> f2<span class="token punctuation">;</span>        f2 <span class="token operator">=</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们通过只记录必要的数据来缩小DP table（即备忘录表）的大小，这个技巧被称为<strong>状态压缩</strong>。</p><p>通过优化，我们最终的时间复杂度为<strong>O(N)</strong>，空间复杂度为<strong>O(1)</strong>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> DP </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Feem：全平台支持的文件互传工具</title>
      <link href="/feem-quan-ping-tai-zhi-chi-de-wen-jian-hu-chuan-gong-ju/"/>
      <url>/feem-quan-ping-tai-zhi-chi-de-wen-jian-hu-chuan-gong-ju/</url>
      
        <content type="html"><![CDATA[<p>偶尔想手机、PC互传个文件，小文件啥的的用QQ到还是挺方便的，但我毕竟是个重度追剧患者，遇到一堆大点的视频传起来体验就不那么好了。比如把一部电影传到手机，首先就是在PC上先用QQ把文件先上传到QQ那边，手机那边再来下载，这一来一回折腾就很费时费力。今天给大家介绍的是一款号称全平台覆盖的文件互传工具：<a href="https://feem.io/" target="_blank" rel="noopener">Feem: Share Files Offline</a>。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200713105923.png" alt="Feem home"></p><h2 id="Core-Features"><a href="#Core-Features" class="headerlink" title="Core Features"></a>Core Features</h2><p>先来看看官方介绍：</p><h3 id="Blazingly-Fast"><a href="#Blazingly-Fast" class="headerlink" title="Blazingly Fast"></a>Blazingly Fast</h3><p>Transfer large files around you in record time. Feem is 50 times faster than Bluetooth. And around twice as fast as Dropbox.</p><p>传输速度比蓝牙快50倍，大约是Dropbox的两倍。</p><h3 id="Unlimited-File-Transfers"><a href="#Unlimited-File-Transfers" class="headerlink" title="Unlimited File Transfers"></a>Unlimited File Transfers</h3><p>Transfer large files around you without breaking the bank. Feem works device, directly to device. No Internet. No File Size Limits.</p><p>不需要Internet支持，也没有文件大小限制。</p><h3 id="Battle-tested-Security"><a href="#Battle-tested-Security" class="headerlink" title="Battle-tested Security"></a>Battle-tested Security</h3><p>Transfer sensitive files in your LAN, without the Cloud. There are no servers to hack into. Plus, Feem encrypts all local transfers with TLS (just like https://).</p><p>通过局域网传输，没有中间服务器，数据通过TLS加密，安全性高。</p><h3 id="All-Your-Devices-Covered"><a href="#All-Your-Devices-Covered" class="headerlink" title="All Your Devices, Covered"></a>All Your Devices, Covered</h3><p>Feem works on all major platforms including: iPhone, iPad, Android, Mac, Windows, Linux. You can Feem files from desktop to desktop, desktop to phone, phone to desktop, and phone to phone.</p><p>基本支持所有设备互传：iPhone, iPad, Android, Mac, Windows, Linux。</p><h3 id="Wi-Fi-Direct"><a href="#Wi-Fi-Direct" class="headerlink" title="Wi-Fi Direct"></a>Wi-Fi Direct</h3><p>Feem can work anywhere, even without a Wi-Fi router. Simply activate Wi-Fi direct inside Feem, or use your phone’s personal hotspot to create a network you can use to share files with.</p><p>即使没有路由器，也可通过设备创建热点方式互传。</p><h3 id="Resumable-File-Transfers"><a href="#Resumable-File-Transfers" class="headerlink" title="Resumable File Transfers"></a>Resumable File Transfers</h3><p>No one likes to restart an interrupted large file transfer. That’s why Feem will resume your file transfer right where you left it, without missing a byte. Saving you a lot of time and headache.</p><p>可恢复的文件传输，不怕传输中断。</p><h3 id="Works-Offline"><a href="#Works-Offline" class="headerlink" title="Works Offline"></a>Works Offline</h3><p>No data? No problem. Feem works completely offline. Your devices need to be running Feem, and should all be connected to the same Wi-Fi/Lan network.</p><p>只需连接同一局域网即可使用，文件传输零流量消耗。</p><h3 id="Chat"><a href="#Chat" class="headerlink" title="Chat"></a>Chat</h3><p>Send text and links directly between your devices. No servers involved. Completely secure. Your messages auto-destroy after 48 hours.</p><p>设备之间还可chat，消息48小时后自动删除。</p><h3 id="Feem-WebShare"><a href="#Feem-WebShare" class="headerlink" title="Feem WebShare"></a>Feem WebShare</h3><p>Don’t wish to install Feem on all your devices? No problem. Introducing Feem’s WebShare. With Feem’s Webshare, you can transfer sensitive documents around you using only your browser. Secured via https and PIN codes.</p><p>不想装app可以使用浏览器通过web界面传输。</p><h2 id="个人测评"><a href="#个人测评" class="headerlink" title="个人测评"></a>个人测评</h2><p>虽然使用时间还不长，但使用方便体验还是很不错的。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>免费，pro功能需要付费，但免费已经够用了</li><li>全平台覆盖，支持iPhone, iPad, Android, Mac, Windows, Linux等</li><li>传输速度快</li><li>安全，局域网传输，TLS加密</li></ul><h4 id="关于费用"><a href="#关于费用" class="headerlink" title="关于费用"></a>关于费用</h4><p>Feem基础版本免费，pro版本需要收费，价格如下：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200713122224.png" alt="Feem Pro Price"></p><h4 id="全平台覆盖"><a href="#全平台覆盖" class="headerlink" title="全平台覆盖"></a>全平台覆盖</h4><p>从下图可以看到Feem支持了绝大多数平台，甚至连Linux都有。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200713111854.png" alt="平台支持"></p><h4 id="传输速度快"><a href="#传输速度快" class="headerlink" title="传输速度快"></a>传输速度快</h4><p>这里我只测试了<strong>Android手机</strong>、<strong>iPad</strong>、<strong>PC</strong>：</p><p>实测用<strong>电脑</strong>向<strong>iPad</strong>大约两分钟传输完一部2G的电影，传输速度甚至达到了<strong>30MB/s</strong>！</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200713121607.png" alt="PC2iPad测试图"></p><p>用<strong>Android手机</strong>向<strong>iPad</strong>传输一部138MB的MV大约几十秒，速度全程在5MB/s左右。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200713121605.png" alt="Android2iPad测试图"></p><p>速度方面真是没得说，主要用起来真的很方便，无线传输还解放了数据线。传输速度和<strong>路由器</strong>有关系，博主的路由器是Redmi AC2100，三个设备都是连接的5G频段的WiFi，路由器好些传输的要快些；和<strong>设备</strong>也有点关系，WiFi天线差的话可能要慢点。速度慢的话可以通过WiFi-Direct模式适当提速。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>主要是<strong>免费版</strong>才有缺点。</p><ul><li>轻度广告</li><li>不能自定义设备名字</li><li>不能自定义文件保存位置</li></ul><h4 id="广告"><a href="#广告" class="headerlink" title="广告"></a>广告</h4><p>广告这个吧，个人感觉还行，传输文件时会弹屏广告，不过广告可以手动关闭，并不影响传输。</p><h4 id="不可自定义XX"><a href="#不可自定义XX" class="headerlink" title="不可自定义XX"></a>不可自定义XX</h4><p>不可自定义设备名字倒是一点没有影响。不过不能自定义文件保存位置倒是有点令人蛋疼，有时可能需要传输完文件后手动迁移一下，值得一提的是移动端点击文件可以查看文件保存路径，PC端点击文件可以打开文件保存位置。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200713121555.png" alt="缺点"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优点：</p><ul><li>免费，pro功能需要付费，但免费已经够用了</li><li>全平台覆盖，支持iPhone, iPad, Android, Mac, Windows, Linux等</li><li>传输速度快</li><li>安全，局域网传输，TLS加密</li></ul><p>缺点（免费版）：</p><ul><li>轻度广告</li><li>不能自定义设备名字</li><li>不能自定义文件保存位置</li></ul><p>整体来说，Feem算是相当良心了，用起来体验也是十分不错的，经常有文件互传方面需求的人士值得试用一下</p><p><a href="https://feem.io/#download" target="_blank" rel="noopener">Feem下载地址</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件互传 </tag>
            
            <tag> offline </tag>
            
            <tag> 免费 </tag>
            
            <tag> LAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 删除博客文章</title>
      <link href="/hexo-shan-chu-wen-zhang/"/>
      <url>/hexo-shan-chu-wen-zhang/</url>
      
        <content type="html"><![CDATA[<p>刚刚接触博客，先尝试了下用 <code>hexo</code> + <code>github</code> 搭建了一个免费博客。虽然博客很早就搭起来了但是第一篇博客这两天才写出来。。毕竟还是小白操作啥的真是一窍不通，连删除博客文章都还不会，网上查阅了下记在这里权当备忘录了：</p><h2 id="删除文章的过程："><a href="#删除文章的过程：" class="headerlink" title="删除文章的过程："></a>删除文章的过程：</h2><ol><li><p>删除本地文件 xx.md</p></li><li><p>通过生成和部署命令进而将远程仓库中的文件也一并删除</p></li></ol><h2 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h2><p>具体来说，以最开始默认形成的helloworld.md这篇文章为例。</p><p>首先进入到存放博客的目录里source / _post 文件夹中，找到helloworld.md文件，在本地直接执行删除。然后依次执行<code>hexo g</code>，<code>hexo d</code>，再去主页查看你就会发现你的博客上面要删除的文章已经消失无踪了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB报错：未定义函数或变量</title>
      <link href="/matlab-bao-cuo-wei-ding-yi-han-shu-huo-bian-liang/"/>
      <url>/matlab-bao-cuo-wei-ding-yi-han-shu-huo-bian-liang/</url>
      
        <content type="html"><![CDATA[<p>最近准备数学建模比赛，学习MATLAB入门遇到了个问题：<code>未定义函数或变量 'myGcd'</code>。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200630173235.png" alt="MATLAB报错图片"></p><p>谷歌了下试了几个方案还是没解决。</p><p>参考官方的文档也没发现哪里有问题（其实是我一开始没看到）</p><p>小白真心累。</p><h2 id="常见错误原因"><a href="#常见错误原因" class="headerlink" title="常见错误原因"></a>常见错误原因</h2><p>先看看<strong>MATLAB官方文档</strong>：</p><p>这些错误通常指示 MATLAB 在当前目录或搜索路径中找不到特定的变量或 MATLAB 程序文件。其根本原因可能是下面这些原因中的一个：</p><ul><li>函数的名称拼写错误。</li><li>函数名称和包含函数的文件的名称不相同。</li><li>未安装函数所属的工具箱。</li><li>函数的搜索路径已更改。</li><li>函数是您没有许可证的工具箱的一部分。</li></ul><p>遇到此类错误时，请按照本节所述<strong>步骤</strong>来解决问题。</p><ol><li><p>验证函数名称的拼写</p></li><li><p>确保函数名称与文件名匹配</p></li><li><p>确保安装了工具箱</p></li><li><p>验证访问函数所用的路径</p></li></ol><p> 这里不做具体解释，详情请移步官网：<a href="https://ww2.mathworks.cn/help/matlab/matlab_prog/calling-functions.html" target="_blank" rel="noopener">MATLAB-调用函数时的常见错误</a></p><h2 id="我的解决方案"><a href="#我的解决方案" class="headerlink" title="我的解决方案"></a>我的解决方案</h2><p>当时有点急了，文档都是跳着看（真的要认真看文档啊！！！），我先是试了1，4步骤，结果都没解决问题。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200630173430.png" alt=""></p><p>最后沉下心来，看了下自己写的几个脚本，其中写了两个函数，一个是myFun，另一个是myGcd，我在想为什么我的myFun就能用，我的myGcd就不行。看着看着发现了端倪！我的myGcd<strong>函数名称和文件名不一样</strong>！也就是MATLAB官方给的帮助文档里的第2条。</p><p>我<strong>把文件名改成和函数名一样</strong>就正常使用，没有问题了！</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200630173511.png" alt="问题解决图片"></p><p>小问题多耽误半天时间，哎，希望我的经历有帮到你！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 函数报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hello World </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
