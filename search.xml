<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>学习使用Git（一）</title>
      <link href="/xue-xi-shi-yong-git-yi/"/>
      <url>/xue-xi-shi-yong-git-yi/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-简介"><a href="#Git-简介" class="headerlink" title="Git 简介"></a>Git 简介</h1><h2 id="Git-是什么"><a href="#Git-是什么" class="headerlink" title="Git 是什么"></a>Git 是什么</h2><p><a href="https://git-scm.com/" target="_blank" rel="noopener"><strong>Git</strong></a>是一款免费、开源的<strong>分布式版本控制系统</strong>，用于敏捷高效地处理任何或小或大的项目。</p><p>Git是一个开源的分布式版本控制系统，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 <strong>Linus Torvalds</strong> 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p><h2 id="Git-特点"><a href="#Git-特点" class="headerlink" title="Git 特点"></a>Git 特点</h2><p><strong>优点</strong>：</p><ul><li><p>适合分布式开发，强调个体；</p></li><li><p>公共服务器压力和数据量都不会太大；</p></li><li><p>速度快、灵活；</p></li><li><p>任意两个开发者之间可以很容易的解决冲突；</p></li><li><p>离线工作。</p></li></ul><p><strong>缺点</strong>：</p><ul><li><p>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息；</p></li><li><p>权限控制不友好；如果需要对开发者限制各种权限的建议使用SVN。</p></li></ul><h1 id="Git-安装"><a href="#Git-安装" class="headerlink" title="Git 安装"></a>Git 安装</h1><h3 id="在Linux上安装Git"><a href="#在Linux上安装Git" class="headerlink" title="在Linux上安装Git"></a>在Linux上安装Git</h3><p>首先，你可以试着输入<code>git</code>，看看系统有没有安装Git：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span>The program <span class="token string">'git'</span> is currently not installed. You can <span class="token function">install</span> it by typing:<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">git</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p><p>如果你碰巧用Debian或Ubuntu Linux，通过一条<code>sudo apt-get install git</code>就可以直接完成Git的安装，非常简单。</p><p>老一点的Debian或Ubuntu Linux，要把命令改为<code>sudo apt-get install git-core</code>，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫<code>git-core</code>了。由于Git名气实在太大，后来就把GNU Interactive Tools改成<code>gnuit</code>，<code>git-core</code>正式改为<code>git</code>。</p><p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code>这几个命令安装就好了。</p><h3 id="在Mac-OS-X上安装Git"><a href="#在Mac-OS-X上安装Git" class="headerlink" title="在Mac OS X上安装Git"></a>在Mac OS X上安装Git</h3><p>如果你正在使用Mac做开发，有两种安装Git的方法。</p><p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<a href="http://brew.sh/。" target="_blank" rel="noopener">http://brew.sh/。</a></p><p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105102730.jpeg" alt="install-git-by-xcode"></p><p>Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！</p><h3 id="在Windows上安装Git"><a href="#在Windows上安装Git" class="headerlink" title="在Windows上安装Git"></a>在Windows上安装Git</h3><p>在Windows上使用Git，可以从Git官网直接<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">下载安装程序</a>，然后按默认选项安装即可。</p><p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105102951.png" alt="Windows上的 Git Bash"></p><p>安装完成后，还需要最后一步设置，在命令行输入：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> config --global user.name <span class="token string">"Your Name"</span>$ <span class="token function">git</span> config --global user.email <span class="token string">"email@example.com"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p><p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p><h1 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h1><h2 id="创建空版本库"><a href="#创建空版本库" class="headerlink" title="创建空版本库"></a>创建空版本库</h2><p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p><p>所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> learngit$ <span class="token function">cd</span> learngit$ <span class="token function">pwd</span>Path----C:\Users\DearDeer\desktop\learngit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>pwd</code>命令用于显示当前目录。如果你使用Windows系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105103542.png" alt="创建版本库"></p><p>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> initInitialized empty Git repository <span class="token keyword">in</span> C:/Users/DearDeer/Desktop/learngit/.git/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p><p>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p><p>也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。</p><h2 id="添加文件到版本库"><a href="#添加文件到版本库" class="headerlink" title="添加文件到版本库"></a>添加文件到版本库</h2><p>首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p><p>不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p><p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p><p>使用Windows的童鞋要特别注意：</p><p>千万不要使用Windows自带的<strong>记事本</strong>编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<a href="http://notepad-plus-plus.org/" target="_blank" rel="noopener">Notepad++</a>代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105104250.png" alt="设置notepad++编码"></p><p>言归正传，现在我们编写一个<code>readme.txt</code>文件，内容如下：</p><pre class="line-numbers language-bash"><code class="language-bash">Git is a version control system.Git is <span class="token function">free</span> software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>一定要放到<code>learngit</code>目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p><p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p><p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p><p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p><pre class="line-numbers language-bash"><code class="language-bash"><span class="token function">git</span> commit -m <span class="token string">"wrote a readme file"</span><span class="token punctuation">[</span>master <span class="token punctuation">(</span>root-commit<span class="token punctuation">)</span> c2a7d3b<span class="token punctuation">]</span> wrote a readme <span class="token function">file</span> 1 <span class="token function">file</span> changed, 2 insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode 100644 readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p><p>嫌麻烦不想输入<code>-m "xxx"</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p><p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p><p>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，比如：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add file1.txt$ <span class="token function">git</span> add file2.txt file3.txt$ <span class="token function">git</span> commit -m <span class="token string">"add 3 files."</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="疑难解答"><a href="#疑难解答" class="headerlink" title="疑难解答"></a>疑难解答</h2><p>Q：输入<code>git add readme.txt</code>，得到错误：<code>fatal: not a git repository (or any of the parent directories)</code>。</p><p>A：Git命令必须在Git仓库目录内执行（<code>git init</code>除外），在仓库目录外执行是没有意义的。</p><p>Q：输入<code>git add readme.txt</code>，得到错误<code>fatal: pathspec 'readme.txt' did not match any files</code>。</p><p>A：添加某个文件时，该文件必须在当前目录下存在，用<code>ls</code>或者<code>dir</code>命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名。</p><h1 id="Git-版本控制"><a href="#Git-版本控制" class="headerlink" title="Git 版本控制"></a>Git 版本控制</h1><h2 id="提交修改"><a href="#提交修改" class="headerlink" title="提交修改"></a>提交修改</h2><p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：</p><pre class="line-numbers language-bash"><code class="language-bash">Git is a distributed version control system.Git is <span class="token function">free</span> software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>现在，运行<code>git status</code>命令看看结果：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file>..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git restore &lt;file>..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>    modified:   readme.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p><p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用<code>git diff</code>这个命令看看：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> readme.txt <span class="token function">diff</span> --git a/readme.txt b/readme.txtindex 46d49bf<span class="token punctuation">..</span>9247db6 100644--- a/readme.txt+++ b/readme.txt@@ -1,2 +1,2 @@-Git is a version control system.+Git is a distributed version control system. Git is <span class="token function">free</span> software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p><p>知道了对<code>readme.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git restore --staged &lt;file>..."</span> to unstage<span class="token punctuation">)</span>    modified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git status</code>告诉我们，将要被提交的修改包括<code>readme.txt</code>，下一步，就可以放心地提交了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> commit -m <span class="token string">"add distributed"</span><span class="token punctuation">[</span>master ce544e3<span class="token punctuation">]</span> add distributed 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, 1 deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提交后，我们再用<code>git status</code>命令看看仓库的当前状态：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masternothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p><pre class="line-numbers language-bash"><code class="language-bash">Git is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>然后尝试提交：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add readme.txt$ <span class="token function">git</span> commit -m <span class="token string">"append GPL"</span><span class="token punctuation">[</span>master df09e99<span class="token punctuation">]</span> append GPL 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, 1 deletion<span class="token punctuation">(</span>-<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p><p>现在，我们回顾一下<code>readme.txt</code>文件一共有几个版本被提交到Git仓库里了：</p><p>版本1：wrote a readme file</p><pre class="line-numbers language-bash"><code class="language-bash">Git is a version control system.Git is <span class="token function">free</span> software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>版本2：add distributed</p><pre class="line-numbers language-bash"><code class="language-bash">Git is a distributed version control system.Git is <span class="token function">free</span> software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>版本3：append GPL</p><pre class="line-numbers language-bash"><code class="language-bash">Git is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> logAuthor: DearDeer7 <span class="token operator">&lt;</span>deardeer0091@163.com<span class="token operator">></span>Date:   Tue Jan 5 10:59:41 2021 +0800    add GPLcommit ce544e3e9e43af38c459f83a400e622ecc4919c9Date:   Tue Jan 5 10:53:52 2021 +0800    add distributedcommit c2a7d3baae628dffda4fb32e363c72607db9a5ddAuthor: DearDeer7 <span class="token operator">&lt;</span>deardeer0091@163.com<span class="token operator">></span>Date:   Tue Jan 5 10:10:34 2021 +0800    wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p><p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> log --pretty<span class="token operator">=</span>onelinedf09e994aa48bcef68ed696ee0d39164a647c698 <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> master<span class="token punctuation">)</span> add GPLce544e3e9e43af38c459f83a400e622ecc4919c9 add distributedc2a7d3baae628dffda4fb32e363c72607db9a5dd wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>需要友情提示的是，你看到的一大串类似<code>df09e9...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105111620.png" alt="git-log-timeline"></p><p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p><p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>df09e9...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p><p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> reset --hard HEAD^HEAD is now at ce544e3 add distributed<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p><p>看看<code>readme.txt</code>的内容是不是版本<code>add distributed</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>果然被还原了。</p><p>还可以继续回退到上一个版本<code>wrote a readme file</code>，不过且慢，让我们用<code>git log</code>再看看现在版本库的状态：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> logcommit ce544e3e9e43af38c459f83a400e622ecc4919c9 <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> master<span class="token punctuation">)</span>Author: DearDeer7 <span class="token operator">&lt;</span>deardeer0091@163.com<span class="token operator">></span>Date:   Tue Jan 5 10:53:52 2021 +0800    add distributedcommit c2a7d3baae628dffda4fb32e363c72607db9a5ddAuthor: DearDeer7 <span class="token operator">&lt;</span>deardeer0091@163.com<span class="token operator">></span>Date:   Tue Jan 5 10:10:34 2021 +0800    wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p><p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>df09e99...</code>，于是就可以指定回到未来的某个版本：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> reset --hard df09e99HEAD is now at df09e99 append GPL<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p><p>再小心翼翼地看看<code>readme.txt</code>的内容：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>果然，我胡汉三又回来了。</p><p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p><pre class="line-numbers language-ascii"><code class="language-ascii">┌────┐│HEAD│└────┘   │   └──> ○ append GPL        │        ○ add distributed        │        ○ wrote a readme file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>改为指向<code>add distributed</code>：</p><pre class="line-numbers language-ascii"><code class="language-ascii">┌────┐│HEAD│└────┘   │   │    ○ append GPL   │    │   └──> ○ add distributed        │        ○ wrote a readme file<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p><p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p><p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> reflogdf09e99 <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> master<span class="token punctuation">)</span> HEAD@<span class="token punctuation">{</span>0<span class="token punctuation">}</span>: reset: moving to df09e99ce544e3 HEAD@<span class="token punctuation">{</span>1<span class="token punctuation">}</span>: reset: moving to HEAD^df09e99 <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> master<span class="token punctuation">)</span> HEAD@<span class="token punctuation">{</span>2<span class="token punctuation">}</span>: commit: add GPLce544e3 HEAD@<span class="token punctuation">{</span>3<span class="token punctuation">}</span>: commit: add distributedc2a7d3b HEAD@<span class="token punctuation">{</span>4<span class="token punctuation">}</span>: commit <span class="token punctuation">(</span>initial<span class="token punctuation">)</span>: wrote a readme <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>终于舒了口气，从输出可知，<code>append GPL</code>的commit id是<code>df09e99</code>，现在，你又可以乘坐时光机回到未来了。</p><h2 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h2><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p><p>先来看名词解释。</p><h3 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h3><p>就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105133641.png" alt="learngit工作区"></p><h3 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h3><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p><p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105133713.jpeg" alt="git-repo"></p><p>分支和<code>HEAD</code>的概念我们以后再讲。</p><p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p><p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p><p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p><p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p><p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p><p>俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：</p><pre class="line-numbers language-bash"><code class="language-bash">Git is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p><p>先用<code>git status</code>查看一下状态：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file>..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git restore &lt;file>..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>    modified:   readme.txtUntracked files:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file>..."</span> to include <span class="token keyword">in</span> what will be committed<span class="token punctuation">)</span>    LICENSEno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p><p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git restore --staged &lt;file>..."</span> to unstage<span class="token punctuation">)</span>    new file:   LICENSE    modified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，暂存区的状态就变成这样了：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105134103.jpeg" alt="git-stage"></p><p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> commit -m <span class="token string">"understand how stage works"</span><span class="token punctuation">[</span>master e43a48b<span class="token punctuation">]</span> understand how stage works 2 files changed, 2 insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span> create mode 100644 LICENSE<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masternothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>现在版本库变成了这样，暂存区就没有任何内容了：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20210105134355.jpeg" alt="git-stage-after-commit"></p><h2 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h2><p>现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p><p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p><p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>然后，添加：</p><pre><code>$ git add readme.txt$ git statusOn branch masterChanges to be committed:  (use "git restore --staged &lt;file&gt;..." to unstage)        modified:   readme.txt</code></pre><p>然后，再修改readme.txt：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txt Git is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>提交：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> commit -m <span class="token string">"git tracks changes"</span><span class="token punctuation">[</span>master 2bdee35<span class="token punctuation">]</span> <span class="token function">git</span> tracks changes 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>提交后，再看看状态：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch master  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file>..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git restore &lt;file>..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>        modified:   readme.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>咦，怎么第二次的修改没有被提交？</p><p>别激动，我们回顾一下操作过程：</p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p><p>你看，我们前面讲了，Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p><p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">diff</span> HEAD -- readme.txt <span class="token function">diff</span> --git a/readme.txt b/readme.txtindex 8d86265<span class="token punctuation">..</span>ffa9ce8 100644--- a/readme.txt+++ b/readme.txt@@ -1,4 +1,4 @@ Git is a distributed version control system. Git is a <span class="token function">free</span> software distributed under the GPL. Git has a mutable index called stage.-Git tracks changes.\ No newline at end of <span class="token function">file</span>+Git tracks changes of files.\ No newline at end of <span class="token function">file</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可见，第二次修改确实没有被提交。</p><p>那怎么提交第二次修改呢？你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了：</p><p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p><h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在<code>readme.txt</code>中添加了一行：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在你准备提交前，一杯咖啡起了作用，你猛然发现了<code>stupid boss</code>可能会让你丢掉这个月的奖金！</p><p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file>..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git restore &lt;file>..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>        modified:   readme.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>你可以发现，Git会告诉你，<code>git restore &lt;file&gt;</code>可以丢弃工作区的修改：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> restore readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>命令<code>git restore readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p><p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p><p>现在，看看<code>readme.txt</code>的文件内容：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>文件内容果然复原了。</p><p>现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">cat</span> readme.txtGit is a distributed version control system.Git is <span class="token function">free</span> software distributed under the GPL.Git has a mutable index called stage.Git tracks changes of files.My stupid boss still prefers SVN.$ <span class="token function">git</span> add readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges to be committed:  <span class="token punctuation">(</span>use <span class="token string">"git restore --staged &lt;file>..."</span> to unstage<span class="token punctuation">)</span>        modified:   readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Git同样告诉我们，用命令<code>git restore --staged &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> restore --staged readme.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add &lt;file>..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git restore &lt;file>..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>        modified:   readme.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>还记得如何丢弃工作区的修改吗？</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> restore readme.txt$ <span class="token function">git</span> statusOn branch masternothing to commit, working tree clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>整个世界终于清静了！</p><p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把<code>stupid boss</code>提交推送到远程版本库，你就真的惨了……</p><h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> add test.txt$ <span class="token function">git</span> commit -m <span class="token string">"add test.txt"</span><span class="token punctuation">[</span>master c6f2547<span class="token punctuation">]</span> add test.txt 1 <span class="token function">file</span> changed, 0 insertions<span class="token punctuation">(</span>+<span class="token punctuation">)</span>, 0 deletions<span class="token punctuation">(</span>-<span class="token punctuation">)</span> create mode 100644 test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p><pre><code>$ rm test.txt</code></pre><p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> statusOn branch masterChanges not staged <span class="token keyword">for</span> commit:  <span class="token punctuation">(</span>use <span class="token string">"git add/rm &lt;file>..."</span> to update what will be committed<span class="token punctuation">)</span>  <span class="token punctuation">(</span>use <span class="token string">"git restore &lt;file>..."</span> to discard changes <span class="token keyword">in</span> working directory<span class="token punctuation">)</span>        deleted:    test.txtno changes added to commit <span class="token punctuation">(</span>use <span class="token string">"git add"</span> and/or <span class="token string">"git commit -a"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> <span class="token function">rm</span> test.txt<span class="token function">rm</span> <span class="token string">'test.txt'</span>$ <span class="token function">git</span> commit -m <span class="token string">"rm test.txt"</span><span class="token punctuation">[</span>master 59826ca<span class="token punctuation">]</span> <span class="token function">rm</span> test.txt delete mode 100644 test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>现在，文件就从版本库中被删除了。</p><p>小提示：先手动删除文件，然后使用<code>git rm &lt;file&gt;</code>和<code>git add&lt;file&gt;</code>效果是一样的。</p><p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p><pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token function">git</span> restore test.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p> 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><ul><li><p>初始化一个Git仓库，使用<code>git init</code>命令。</p></li><li><p>添加文件到Git仓库，分两步：</p><ol><li><p>使用命令<code>git add</code>，注意，可反复多次使用，添加多个文件；</p></li><li><p>使用命令<code>git commit -m</code>，完成。</p></li></ol></li></ul><ul><li><p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p></li><li><p>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p></li></ul><ul><li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li><li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li><li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li></ul><ul><li><p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git restore &lt;file&gt;</code>。</p></li><li><p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git restore --staged &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p></li><li><p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p></li></ul><ul><li>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 教程 </tag>
            
            <tag> CLI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串流 istringstream 和 ostringstream 的用法</title>
      <link href="/zi-fu-chuan-liu-istringstream-he-ostringstream-de-yong-fa/"/>
      <url>/zi-fu-chuan-liu-istringstream-he-ostringstream-de-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>iostream 标准库支持内存中的输入／输出，只要将流与存储在程序内存中的 string 对象捆绑起来即可。此时，可使用 iostream 输入和输出操作符读写这个 string 对象。</p><p>标准库定义了三种类型的字符串流：</p><ul><li><p><code>istringstream</code>，由 istream 派生而来，提供<strong>读</strong> string 的功能。</p></li><li><p><code>ostringstream</code>，由 ostream 派生而来，提供<strong>写</strong> string 的功能。</p></li><li><p><code>stringstream</code>，由 iostream 派生而来，提供<strong>读写</strong> string 的功能。</p><p>要使用上述类，必须包含 <code>sstream</code> 头文件。</p></li></ul><p>与 fstream 类型一样，上述类型由 iostream 类型派生而来，这意味着 iostream 上所有的操作适用于 sstream 中的类型。sstream 类型除了继承的操作外，还各自定义了一个有 string 形参的构造函数，这个构造函数将 string 类型的实参复制给 stringstream 对象。对 stringstream 的读写操作实际上读写的就是该对象中的 string 对象。这些类还定义了名为 str 的成员，用来读取或设置 stringstream 对象所操纵的 string 值。</p><p>注意到尽管 fstream 和 sstream 共享相同的基类，但它们没有其他相互关系。特别是，stringstream 对象不使用open 和 close 函数，而 fstream 对象则不允许使用 str。</p><h2 id="2-stringstram常用操作"><a href="#2-stringstram常用操作" class="headerlink" title="2.stringstram常用操作"></a>2.stringstram常用操作</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token comment" spellcheck="true">// 创建stringstream对象</span>stringstream stream<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建以s为副本的stringstream对象</span>string s <span class="token operator">=</span> <span class="token string">"deardeer.tech"</span><span class="token punctuation">;</span>stringstream <span class="token function">stream</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 返回一个string对象，值为当前stringstream对象的内容</span>stream<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 拷贝s的内容到stream中</span>stream<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="3-istringstream"><a href="#3-istringstream" class="headerlink" title="3.istringstream"></a>3.istringstream</h2><pre class="line-numbers language-cpp"><code class="language-cpp">istringstream <span class="token function">istrm</span><span class="token punctuation">(</span><span class="token string">"1 2 3 4 5 6 7 8 9 10"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>string word<span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>istrm <span class="token operator">>></span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> word <span class="token operator">&lt;&lt;</span> <span class="token string">'|'</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 运行结果：1|2|3|4|5|6|7|8|9|10|</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="2-ostringstream"><a href="#2-ostringstream" class="headerlink" title="2.ostringstream"></a>2.ostringstream</h2><pre class="line-numbers language-cpp"><code class="language-cpp">ostringstream ostrm<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 将10,9,8,7,..,1写入ostringstream</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ostrm <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出ostringstream的内容</span><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">char</span> c <span class="token operator">:</span> ostrm<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 运行结果：10 9 8 7 6 5 4 3 2 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="4-简单应用"><a href="#4-简单应用" class="headerlink" title="4.简单应用"></a>4.简单应用</h4><h3 id="a-特殊读入"><a href="#a-特殊读入" class="headerlink" title="a.特殊读入"></a>a.特殊读入</h3><p>一般我们可以每次一个单词或每次一行的方式处理输入的程序。第一种程序用 string 输入操作符，而第二种则使用 getline 函数。然而，有些程序需要同时使用这两种方式：有些处理基于每行实现，而其他处理则要操纵每行中每个单词。这时候我们可用 stringstream 对象实现：</p><pre class="line-numbers language-cpp"><code class="language-cpp">string sentence<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 以行为单位操作</span><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">getline</span><span class="token punctuation">(</span>cin<span class="token punctuation">,</span> sentence<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    istringstream <span class="token function">istrm</span><span class="token punctuation">(</span>sentence<span class="token punctuation">)</span><span class="token punctuation">;</span>    string word<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>istrm <span class="token operator">>></span> word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 以单词为单位操作</span>        cout <span class="token operator">&lt;&lt;</span> word <span class="token operator">&lt;&lt;</span> <span class="token string">"#"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输入：Hello everyone! This is an ostringstream example!</span><span class="token comment" spellcheck="true">// 输出：Hello#everyone!#This#is#an#ostringstream#example!#</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="b-格式化读写、转换"><a href="#b-格式化读写、转换" class="headerlink" title="b.格式化读写、转换"></a>b.格式化读写、转换</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">;</span><span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">77.77</span><span class="token punctuation">;</span>ostringstream ostrm<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 写入ostringstream</span>ostrm <span class="token operator">&lt;&lt;</span> <span class="token string">"integer: "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" float: "</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> ostrm<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 此时ostrm内容为：integer: 7 float: 77.77</span><span class="token keyword">int</span> c<span class="token punctuation">;</span><span class="token keyword">double</span> d<span class="token punctuation">;</span>istringstream <span class="token function">istrm</span><span class="token punctuation">(</span>ostrm<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>string ts<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 从istringstream读出</span>istrm <span class="token operator">>></span> ts <span class="token operator">>></span> c <span class="token operator">>></span> ts <span class="token operator">>></span> d<span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> d <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 运行结果：</span><span class="token comment" spellcheck="true">// integer: 7 float: 77.77</span><span class="token comment" spellcheck="true">// 7 77.77</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串流 </tag>
            
            <tag> stringstram </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ lower_bound() 和 upper_bound() 用法</title>
      <link href="/c-lower-bound-he-upper-bound-yong-fa/"/>
      <url>/c-lower-bound-he-upper-bound-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>​    </p><p><code>lower_bound()</code> 和 <code>upper_bound()</code> 包含在头文件<code>&lt;algorithm&gt;</code>中。</p><p><code>lower_bound()</code>和<code>upper_bound()</code>都是利用二分查找的方法在一个排好序的数组中进行查找的，数组排序默认从小到大。</p><h2 id="2-函数介绍"><a href="#2-函数介绍" class="headerlink" title="2.函数介绍"></a>2.函数介绍</h2><h3 id="lower-bound"><a href="#lower-bound" class="headerlink" title="lower_bound()"></a>lower_bound()</h3><ul><li><p>default : <code>it lower_bound(it first, it last, const &amp;val);</code> (it 表示iterator)</p></li><li><p>custom : <code>it lower_bound(it first, it last, const &amp;val, compare cmp);</code></p><p>Returns an iterator pointing to the first element in the range [first,last) which does <strong>not compare less than val</strong>. 函数返回  [first,last) 区间中不小于val的元素的迭代器指针， 如果找不到返回last。</p></li></ul><h3 id="upper-bound"><a href="#upper-bound" class="headerlink" title="upper_bound()"></a>upper_bound()</h3><ul><li><p>default : <code>it upper_bound(it first, it last, const &amp;val);</code> (it 表示iterator)</p></li><li><p>custom : <code>it upper_bound(it first, it last, const &amp;val, compare cmp);</code></p><p>Returns an iterator pointing to the first element in the range [first,last) which <strong>compares greater than val</strong>. 函数返回  [first,last) 区间中大于val的元素的迭代器指针，如果找不到返回last。</p></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> pos1 <span class="token operator">=</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">-</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pos2 <span class="token operator">=</span> <span class="token function">upper_bound</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">-</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pos1 : "</span> <span class="token operator">&lt;&lt;</span> pos1 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pos1 : 2</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pos2 : "</span> <span class="token operator">&lt;&lt;</span> pos2 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pos2 : 5</span><span class="token keyword">int</span> pos3 <span class="token operator">=</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pos4 <span class="token operator">=</span> <span class="token function">upper_bound</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">-</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pos3 : "</span> <span class="token operator">&lt;&lt;</span> pos3 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pos3 : 0</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pos4 : "</span> <span class="token operator">&lt;&lt;</span> pos4 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pos4 : 6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们可以发现：</p><p><code>lower_bound()</code> 得到的结果表示：<code>val</code>在数组最<strong>早</strong>能插入到那个位置</p><p><code>upper_bound()</code>得到的结果表示：<code>val</code>在数组最<strong>晚</strong>能插入到那个位置</p><h3 id="cmp"><a href="#cmp" class="headerlink" title="cmp"></a>cmp</h3><p><code>lower_bound()</code> 和 <code>upper_bound()</code>查找的数组是默认是从小到大排序的，如果我们的数组是从大到小排序的该怎么办？</p><p>一个容易想到的解决办法是我们可以先将数组逆序，然后正常查找即可。</p><p>其实我们可以使用<code>lower_bound()</code> 和 <code>upper_bound()</code>的第四个参数<code>cmp</code>，我们可以这样写：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a <span class="token operator">></span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp">vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> v<span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">int</span> pos5 <span class="token operator">=</span> <span class="token function">lower_bound</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span> <span class="token operator">-</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> pos6 <span class="token operator">=</span> <span class="token function">upper_bound</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span> <span class="token operator">-</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pos5 : "</span> <span class="token operator">&lt;&lt;</span> pos5 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pos3 : 4</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"pos6 : "</span> <span class="token operator">&lt;&lt;</span> pos6 <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//pos4 : 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>当然我们也可以用<code>greater&lt;type&gt;()</code>代替 <code>cmp</code>，效果是一样的。</p><p>我们总结发现：</p><p>lower_bound() 在数组中找出 val的左边界， upper_bound() 在数组中找出val的右边界，而且结果正好符合[val)，左闭右开。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 库函数 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++11 Lambda表达式</title>
      <link href="/c-11-lambda-biao-da-shi/"/>
      <url>/c-11-lambda-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/DswCnblog/p/5629165.html" target="_blank" rel="noopener">参考1</a></p><p><a href="https://docs.microsoft.com/zh-cn/cpp/cpp/lambda-expressions-in-cpp?view=vs-2019" target="_blank" rel="noopener">参考2</a></p><p>C++11的一大亮点就是引入了Lambda表达式。利用Lambda表达式，可以方便的定义和创建匿名函数。对于C++这门语言来说来说，“Lambda表达式”或“匿名函数”这些概念听起来好像很深奥，但很多高级语言在很早以前就已经提供了Lambda表达式的功能，如C#，<a href="http://lib.csdn.net/base/11" target="_blank" rel="noopener">Python</a>等。今天，我们就来简单介绍一下C++中Lambda表达式的简单使用。</p><h2 id="声明Lambda表达式"><a href="#声明Lambda表达式" class="headerlink" title="声明Lambda表达式"></a><strong>声明Lambda表达式</strong></h2><p>Lambda表达式完整的声明格式如下：</p><pre><code>[capture list] (params list) mutable exception-&gt; return type { function body }</code></pre><p>各项具体含义如下</p><ol><li>capture list：捕获外部变量列表</li><li>params list：形参列表</li><li>mutable指示符：用来说用是否可以修改捕获的变量</li><li>exception：异常设定</li><li>return type：返回类型</li><li>function body：函数体</li></ol><p>此图显示了 lambda 的组成部分：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/20200917175518.png" alt="lambda 表达式的结构化元素"></p><ol><li><em>捕获子句</em>（在 c + + 规范中也称为<em>lambda 引导</em>）。</li><li><em>参数列表</em>可有可无. （也称为<em>lambda 声明符</em>）</li><li><em>可变规范</em>可有可无.</li><li><em>异常规范</em>可有可无.</li><li><em>尾随-返回类型</em>可有可无.</li><li><em>lambda 体</em>。</li></ol><p>此外，我们还可以省略其中的某些成分来声明“不完整”的Lambda表达式，常见的有以下几种：</p><table><thead><tr><th>序号</th><th>格式</th></tr></thead><tbody><tr><td>1</td><td>[capture list] (params list) -&gt; return type {function body}</td></tr><tr><td>2</td><td>[capture list] (params list) {function body}</td></tr><tr><td>3</td><td>[capture list] {function body}</td></tr></tbody></table><p>其中：</p><ul><li><p>格式1声明了const类型的表达式，这种类型的表达式不能修改捕获列表中的值。</p></li><li><p>格式2省略了返回值类型，但编译器可以根据以下规则推断出Lambda表达式的返回类型： （1）：如果function body中存在return语句，则该Lambda表达式的返回类型由return语句的返回类型确定； （2）：如果function body中没有return语句，则返回值为void类型。</p></li><li><p>格式3中省略了参数列表，类似普通函数中的无参函数。</p><p>讲了这么多，我们还没有看到Lambda表达式的庐山真面目，下面我们就举一个实例。</p></li></ul><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;algorithm></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">bool</span> <span class="token function">cmp</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span>  a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> myvec<span class="token punctuation">{</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">lbvec</span><span class="token punctuation">(</span>myvec<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>myvec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> myvec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cmp<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 旧式做法</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"predicate function:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> it <span class="token operator">:</span> myvec<span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> it <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span>    cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token function">sort</span><span class="token punctuation">(</span>lbvec<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lbvec<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">bool</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// Lambda表达式</span>    cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lambda expression:"</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> it <span class="token operator">:</span> lbvec<span class="token punctuation">)</span>        cout <span class="token operator">&lt;&lt;</span> it <span class="token operator">&lt;&lt;</span> <span class="token string">' '</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在C++11之前，我们使用STL的sort函数，需要提供一个谓词函数。如果使用C++11的Lambda表达式，我们只需要传入一个匿名函数即可，方便简洁，而且代码的可读性也比旧式的做法好多了。</p><p>下面，我们就重点介绍一下Lambda表达式各项的具体用法。</p><h2 id="捕获外部变量"><a href="#捕获外部变量" class="headerlink" title="捕获外部变量"></a><strong>捕获外部变量</strong></h2><p>Lambda表达式可以使用其可见范围内的外部变量，但必须明确声明（明确声明哪些外部变量可以被该Lambda表达式使用）。那么，在哪里指定这些外部变量呢？Lambda表达式通过在最前面的方括号[]来明确指明其内部可以访问的外部变量，这一过程也称过Lambda表达式“捕获”了外部变量。</p><p>我们通过一个例子来直观地说明一下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：123</span>    <span class="token comment" spellcheck="true">//或通过“函数体”后面的‘()’传入参数</span>    <span class="token keyword">auto</span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">{</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面这个例子先声明了一个整型变量a，然后再创建Lambda表达式，该表达式“捕获”了a变量，这样在Lambda表达式函数体中就可以获得该变量的值。</p><p>类似参数传递方式（值传递、引入传递、指针传递），在Lambda表达式中，外部变量的捕获方式也有值捕获、引用捕获、隐式捕获。</p><h3 id="1、值捕获"><a href="#1、值捕获" class="headerlink" title="1、值捕获"></a><strong>1、值捕获</strong></h3><p>值捕获和参数传递中的值传递类似，被捕获的变量的值在Lambda表达式创建时通过值拷贝的方式传入，因此随后对该变量的修改不会影响影响Lambda表达式中的值。</p><p>示例如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>     a <span class="token operator">=</span> <span class="token number">321</span><span class="token punctuation">;</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：123</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里需要注意的是，如果以传值方式捕获外部变量，则在Lambda表达式函数体中不能修改该外部变量的值。</p><h3 id="2、引用捕获"><a href="#2、引用捕获" class="headerlink" title="2、引用捕获"></a><strong>2、引用捕获</strong></h3><p>使用引用捕获一个外部变量，只需要在捕获列表变量前面加上一个引用说明符&amp;。如下：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>a<span class="token punctuation">]</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>     a <span class="token operator">=</span> <span class="token number">321</span><span class="token punctuation">;</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：321</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从示例中可以看出，引用捕获的变量使用的实际上就是该引用所绑定的对象。</p><h3 id="3、隐式捕获"><a href="#3、隐式捕获" class="headerlink" title="3、隐式捕获"></a><strong>3、隐式捕获</strong></h3><p>上面的值捕获和引用捕获都需要我们在捕获列表中显示列出Lambda表达式中使用的外部变量。除此之外，我们还可以让编译器根据函数体中的代码来推断需要捕获哪些变量，这种方式称之为隐式捕获。隐式捕获有两种方式，分别是[=]和[&amp;]。[=]表示以值捕获的方式捕获外部变量，[&amp;]表示以引用捕获的方式捕获外部变量。</p><p>隐式值捕获示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 值捕获</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：123</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>隐式引用捕获示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 引用捕获</span>    a <span class="token operator">=</span> <span class="token number">321</span><span class="token punctuation">;</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：321</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4、混合方式"><a href="#4、混合方式" class="headerlink" title="4、混合方式"></a><strong>4、混合方式</strong></h3><p>上面的例子，要么是值捕获，要么是引用捕获，Lambda表达式还支持混合的方式捕获外部变量，这种方式主要是以上几种捕获方式的组合使用。</p><p>到这里，我们来总结一下：C++11中的Lambda表达式捕获外部变量主要有以下形式：</p><table><thead><tr><th>捕获形式</th><th>说明</th></tr></thead><tbody><tr><td>[]</td><td>不捕获任何外部变量</td></tr><tr><td>[变量名, …]</td><td>默认以值得形式捕获指定的多个外部变量（用逗号分隔），如果引用捕获，需要显示声明（使用&amp;说明符）</td></tr><tr><td>[this]</td><td>以值的形式捕获this指针</td></tr><tr><td>[=]</td><td>以值的形式捕获所有外部变量</td></tr><tr><td>[&amp;]</td><td>以引用形式捕获所有外部变量</td></tr><tr><td>[=, &amp;x]</td><td>变量x以引用形式捕获，其余变量以传值形式捕获</td></tr><tr><td>[&amp;, x]</td><td>变量x以值的形式捕获，其余变量以引用形式捕获</td></tr></tbody></table><h2 id="修改捕获变量"><a href="#修改捕获变量" class="headerlink" title="修改捕获变量"></a><strong>修改捕获变量</strong></h2><p>前面我们提到过，在Lambda表达式中，如果以传值方式捕获外部变量，则函数体中不能修改该外部变量，否则会引发编译错误。那么有没有办法可以修改值捕获的外部变量呢？这是就需要使用mutable关键字，该关键字用以说明表达式体内的代码可以修改值捕获的变量，示例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>a<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 不会报错</span>    cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：123</span>    <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 输出：124</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="Lambda表达式的参数"><a href="#Lambda表达式的参数" class="headerlink" title="Lambda表达式的参数"></a><strong>Lambda表达式的参数</strong></h2><p>Lambda表达式的参数和普通函数的参数类似，那么这里为什么还要拿出来说一下呢？原因是在Lambda表达式中传递参数还有一些限制，主要有以下几点：</p><ol><li>参数列表中不能有默认参数</li><li>不支持可变参数</li><li>所有参数必须有参数名</li></ol><p>常用举例：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token punctuation">{</span>　　　　 <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> y <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">6</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"m:"</span> <span class="token operator">&lt;&lt;</span> m <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>            　　<span class="token comment" spellcheck="true">//输出m:16</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"n:"</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//输出n:9</span>        <span class="token keyword">auto</span> gFunc <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> lFunc <span class="token operator">=</span> <span class="token function">gFunc</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">lFunc</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        <span class="token keyword">auto</span> hFunc <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token operator">&amp;</span> f<span class="token punctuation">,</span> <span class="token keyword">int</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> a <span class="token operator">=</span> <span class="token function">hFunc</span><span class="token punctuation">(</span><span class="token function">gFunc</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">111</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">222</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>b<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">mutable</span> <span class="token punctuation">{</span>             a <span class="token operator">=</span> <span class="token number">22</span><span class="token punctuation">;</span> b <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">;</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a:"</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" b:"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a:"</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" b:"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>        a <span class="token operator">=</span> <span class="token number">333</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> func2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>a<span class="token punctuation">]</span> <span class="token punctuation">{</span>             a <span class="token operator">=</span> <span class="token number">444</span><span class="token punctuation">;</span> std<span class="token operator">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a:"</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" b:"</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> std<span class="token operator">::</span>endl<span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">auto</span> func3 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">></span> <span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span><span class="token punctuation">;</span>    　　　　　　 std<span class="token operator">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">></span> f_display_42 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">print_num</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token function">f_display_42</span><span class="token punctuation">(</span><span class="token number">44</span><span class="token punctuation">)</span><span class="token punctuation">;</span>　　<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++11 </tag>
            
            <tag> Lambda表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ rand 与 srand 的用法</title>
      <link href="/c-rand-yu-srand-de-yong-fa/"/>
      <url>/c-rand-yu-srand-de-yong-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="0-简介"><a href="#0-简介" class="headerlink" title="0.简介"></a>0.简介</h2><p>计算机的随机数都是由伪随机数，即是由小M多项式序列生成的，其中产生每个小序列都有一个初始值，即随机种子。（注意： 小M多项式序列的周期是65535，即每次利用一个随机种子生成的随机数的周期是65535，当你取得65535个随机数后它们又重复出现了。）</p><p>我们知道 rand() 函数可以用来产生随机数，但是这不是真正意义上的随机数，是一个伪随机数，是根据一个数（我们可以称它为种子）为基准以某个递推公式推算出来的一系列数，当这系列数很大的时候，就符合正态公布，从而相当于产生了随机数，但这不是真正的随机数，当计算机正常开机后，这个种子的值是定了的，除非你破坏了系统。</p><h2 id="1-rand"><a href="#1-rand" class="headerlink" title="1.rand()"></a>1.rand()</h2><p>功能:</p><p>随机数发生器</p><p>用法:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所在头文件:</p><pre class="line-numbers language-cpp"><code class="language-cpp">stdlib<span class="token punctuation">.</span>h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>rand() 的内部实现是用线性同余法做的，它不是真的随机数，因其周期特别长，故在一定的范围里可看成是随机的。</p><p>rand() 返回一随机数值的范围在 0 至 RAND_MAX 间。RAND_MAX 的范围最少是在 32767 之间(int)。用 unsigned int 双字节是 65535，四字节是 4294967295 的整数范围。0~RAND_MAX 每个数字被选中的机率是相同的。</p><p>用户未设定随机数种子时，系统默认的随机数种子为 1。</p><p>rand() 产生的是伪随机数字，每次执行时是相同的; 若要不同, 用函数 srand() 初始化它。</p><h2 id="2-srand"><a href="#2-srand" class="headerlink" title="2.srand()"></a>2.srand()</h2><p>功能:</p><p>初始化随机数发生器</p><p>用法:</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">srand</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> seed<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>所在头文件:</p><pre class="line-numbers language-cpp"><code class="language-cpp">stdlib<span class="token punctuation">.</span>h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>srand() 用来设置 rand() 产生随机数时的随机数种子。参数 seed 必须是个整数，如果每次 seed 都设相同值，rand() 所产生的随机数值每次就会一样。</p><h2 id="3-使用当前时钟作为随机数种子"><a href="#3-使用当前时钟作为随机数种子" class="headerlink" title="3.使用当前时钟作为随机数种子"></a>3.使用当前时钟作为随机数种子</h2><p>rand() 产生的随机数在每次运行的时候都是与上一次相同的。若要不同, 用函数 srand() 初始化它。可以利用 srand((unsigned int)(time(NULL)) 的方法，产生不同的随机数种子，因为每一次运行程序的时间是不同的。</p><h2 id="4-产生随机数的用法"><a href="#4-产生随机数的用法" class="headerlink" title="4.产生随机数的用法"></a>4.产生随机数的用法</h2><ul><li>1) 给srand()提供一个种子，它是一个unsigned int类型；</li><li>2) 调用rand()，它会根据提供给srand()的种子值返回一个随机数(在0到RAND_MAX之间)；</li><li>3) 根据需要多次调用rand()，从而不间断地得到新的随机数；</li><li>4) 无论什么时候，都可以给srand()提供一个新的种子，从而进一步”随机化”rand()的输出结果。</li></ul><p>0~RAND_MAX 之间的随机数程序</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;time.h></span> </span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span> <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token function">srand</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span><span class="token punctuation">)</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span> <span class="token punctuation">)</span>                 cout <span class="token operator">&lt;&lt;</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">'/t'</span><span class="token punctuation">;</span>        cout <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>         <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="5-产生一定范围随机数的通用表示公式"><a href="#5-产生一定范围随机数的通用表示公式" class="headerlink" title="5.产生一定范围随机数的通用表示公式"></a>5.产生一定范围随机数的通用表示公式</h2><p>要取得 [a,b) 的随机整数，使用 (rand() % (b-a))+ a;</p><p>要取得 [a,b] 的随机整数，使用 (rand() % (b-a+1))+ a;</p><p>要取得 (a,b] 的随机整数，使用 (rand() % (b-a))+ a + 1;</p><p>通用公式: a + rand() % n；其中的 a 是起始值，n 是整数的范围。</p><p>要取得 a 到 b 之间的随机整数，另一种表示：a + (int)b * rand() / (RAND_MAX + 1)。</p><p>要取得 0～1 之间的浮点数，可以使用 rand() / double(RAND_MAX)。</p><p><code>原文链接：https://www.runoob.com/w3cnote/cpp-rand-srand.html</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 库函数 </tag>
            
            <tag> 随机数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找模板总结</title>
      <link href="/er-fen-cha-zhao-mo-ban/"/>
      <url>/er-fen-cha-zhao-mo-ban/</url>
      
        <content type="html"><![CDATA[<p><strong>三种二分查找场景：</strong></p><ul><li>寻找一个数</li><li>寻找左侧边界</li><li>寻找右侧边界</li></ul><h2 id="零、二分查找框架"><a href="#零、二分查找框架" class="headerlink" title="零、二分查找框架"></a>零、二分查找框架</h2><p><code>l</code> 为左侧边界，<code>r</code> 为右侧边界，<code>nums</code>为查找范围，<code>target</code> 为目标数。</p><p>具体细节再根据需要更改。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            r <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> l <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="一、寻找一个数"><a href="#一、寻找一个数" class="headerlink" title="一、寻找一个数"></a>一、寻找一个数</h2><p><a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener">704. 二分查找</a></p><p>给定一个 <code>n</code> 个元素有序的（升序）整型数组 <code>nums</code> 和一个目标值 <code>target</code>  ，写一个函数搜索 <code>nums</code> 中的 <code>target</code>，如果目标值存在返回下标，否则返回 <code>-1</code>。</p><pre><code>输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4</code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">binarySearch</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> m<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="二、寻找左侧边界"><a href="#二、寻找左侧边界" class="headerlink" title="二、寻找左侧边界"></a>二、寻找左侧边界</h2><p>与上面题目不同的是，升序数组中存在重复的元素，我们需要返回<code>target</code>第一次出现的位置，若没有则返回-<code>1</code>。</p><pre><code>输入: nums = [1,2,3,3,3,6,7], target = 3输出: 2解释: 3 第一次出现在 nums 中的下标为 2</code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">leftBound</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// r = n - 1</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// ！l &lt;= r</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 锁定左边界，收紧右边界</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// while 中止情况为 l = r + 1</span>        <span class="token comment" spellcheck="true">// 根据 l 判断查找情况</span>        <span class="token keyword">return</span> l <span class="token operator">&lt;</span> n <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> l <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="三、寻找右侧边界"><a href="#三、寻找右侧边界" class="headerlink" title="三、寻找右侧边界"></a>三、寻找右侧边界</h2><p>这次的情况同样是存在重复的元素，我们需要返回<code>target</code>最后出现的位置，若没有则返回-<code>1</code>。</p><pre class="line-numbers language-cpp"><code class="language-cpp">输入<span class="token operator">:</span> nums <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span> target <span class="token operator">=</span> <span class="token number">3</span>输出<span class="token operator">:</span> <span class="token number">4</span>解释<span class="token operator">:</span> <span class="token number">3</span> 最后出现在 nums 中的下标为 <span class="token number">4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">rightBound</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ! r = n -1</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// ！l &lt;= r</span>            <span class="token keyword">int</span> m <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 锁定右边界，收紧左边界</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                r <span class="token operator">=</span> m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> l <span class="token operator">=</span> m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// while 中止情况为 l = r + 1</span>        <span class="token comment" spellcheck="true">// 根据 r 判断查找情况</span>        <span class="token keyword">return</span> r <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> r <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h2><p>本文的二分模板基于左闭右闭的搜索区间，即<code>[l, r]</code> ，实际运用中我们也可以采用一般的左闭右开的搜索区间，即<code>[l, r)</code>，我们只需要根据查找情况对对细节部分进行修改：</p><p><strong>寻找左侧边界：</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 参考</span><span class="token keyword">int</span> <span class="token function">left_bound</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 注意</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            right <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            right <span class="token operator">=</span> mid<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 类似之前算法的处理方式</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> left <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>寻找右侧边界：</strong></p><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 参考</span><span class="token keyword">int</span> <span class="token function">right_bound</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> right <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token punctuation">(</span>left <span class="token operator">+</span> right<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 注意</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            left <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>            right <span class="token operator">=</span> mid<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> nums<span class="token punctuation">[</span>left<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> target <span class="token operator">?</span> <span class="token punctuation">(</span>left<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 模板 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>0-1 Knapsack Problem</title>
      <link href="/0-1-knapsack-problem/"/>
      <url>/0-1-knapsack-problem/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p><a href="https://practice.geeksforgeeks.org/problems/0-1-knapsack-problem/0" target="_blank" rel="noopener"><strong>0 - 1 Knapsack Problem</strong></a></p><h3 id="描述："><a href="#描述：" class="headerlink" title="描述："></a><strong>描述：</strong></h3><p>给你<strong>N个</strong>物品的重量和价值，将这些物品放入容量为<strong>W</strong>的背包中，以获取背包中的最大总价值。请注意，<strong>每个项目</strong>只有<strong>一个数量</strong>。<br>换句话说，给定两个整数数组<strong>val [0..N-1]</strong>和<strong>wt [0..N-1]</strong>，它们分别表示与<strong>N个</strong>物品的重量和价值。还要给定代表背包容量的整数<strong>W</strong>，找出<strong>val []</strong>的最大值子集，以使该子集的权重之和小于或等于<strong>W。</strong>你不能破坏某个物品（比如把物品拆分），<strong>只能选择它，或者不要选择它（0-1属性）</strong>。</p><h3 id="输入："><a href="#输入：" class="headerlink" title="输入："></a><strong>输入：</strong></h3><p>的第一行包含一个整数<strong>T，</strong>表示测试用例的数量。然后是 <strong>T</strong>测试用例。每个测试用例包含四行。<br>第一行由<strong>N</strong>个项目组成。<br>第二行包含<strong>W</strong>，即背包的最大容量。<br>在第三行中， <strong>N个</strong>空格分隔的正整数表示<strong>N个</strong>物品的价值，<br>在第四行中，<strong>N个</strong>空格分隔的正整数表示相应物品的重量。</p><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a><strong>输出：</strong></h3><p>对于每个测试用例，在新一行中，输出在给定条件下可以获得的<strong>背包最大价值</strong>。</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><h3 id="明确问题的状态和选择"><a href="#明确问题的状态和选择" class="headerlink" title="明确问题的状态和选择."></a>明确问题的状态和选择.</h3><p>分析题目可以发现问题的状态有两个，背包容量和可选择的物品；对于每个物品，我们在选择时有两种方案：<strong>装进背包</strong>或者<strong>不装进背包</strong>，这也是为什么叫做0-1背包问题。</p><h3 id="定义dp数组"><a href="#定义dp数组" class="headerlink" title="定义dp数组"></a>定义dp数组</h3><p>刚才分析出来问题的状态有两个，因此需要一个二维数组，一维表示可选的物品范围，另一维表示背包的容量。<strong><code>dp[i][j]</code>的定义如下：对于前<code>i</code>个物品，当前背包的容量为<code>j</code>，这种情况下可以装的最大价值是<code>dp[i][j]</code>。</strong></p><p>这样我们最终想要的答案就是<code>dp[N][W]</code>。</p><p>基础状态：<code>dp[..][j] = 0</code>， 因为可选的物品为空，即背包什么都没有装，价值为零；<code>dp[i][..] = 0</code>，因为背包的容量为零，什么也装不了。</p><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>回顾刚才的分析，状态的改变有两个选择：</p><p>对与第i个商品，①不装入背包，那么背包的最大价值<code>dp[i][j]</code>显然是继承<code>dp[i-1][j]</code>，背包的容量和价值都不变。②装入背包，那么背包的最大价值应该是前i-1个物品的最大价值加上第i个商品的价值，换句话说，我们的前提是<strong>装第<code>i</code>个物品</strong>，也就是在剩余重量<code>w-wt[i-1]</code>限制下能装的最大价值，加上第<code>i</code>个物品的价值<code>val[i-1]</code>，即<code>dp[i][j] = dp[i-1][j-wt[i-1]]+val[i-1]</code>。 </p><p>注意：物品的价值和重量数组下标从0开始，即wt[i-1]和al[i-1]分别对应第i个物品的重量和价值。</p><p>综合一下我们的状态转移方程就是：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200725130553.png" alt="状态转移方程"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;iostream></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;vector></span></span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;cmath></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> t<span class="token punctuation">;</span>    cin<span class="token operator">>></span>t<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>w<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cin <span class="token operator">>></span> n <span class="token operator">>></span> w<span class="token punctuation">;</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">val</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token function">wt</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            cin <span class="token operator">>></span> val<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            cin <span class="token operator">>></span> wt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        vector<span class="token operator">&lt;</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">>></span> <span class="token function">dp</span><span class="token punctuation">(</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token punctuation">(</span>w<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> w<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">>=</span>wt<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">-</span>wt<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+</span> val<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        cout <span class="token operator">&lt;&lt;</span> dp<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">[</span>w<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>复杂度分析：</p><ul><li><p>时间复杂度：O(N*W)</p><p>N代表物品的数量，W代表背包的容量。</p></li><li><p>空间复杂度：O(N*W)</p><p>使用一个N*W的二位数组。</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
            <tag> 简单 </tag>
            
            <tag> geeksforgeeks </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中的正无穷和负无穷</title>
      <link href="/c-zhong-de-zheng-wu-qiong-he-fu-wu-qiong/"/>
      <url>/c-zhong-de-zheng-wu-qiong-he-fu-wu-qiong/</url>
      
        <content type="html"><![CDATA[<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><p>如果是<strong>int</strong>，可以用<code>INT_MAX</code>表示正无穷，<code>INT_MIN</code>表示负无穷，需要包含<code>limits.h</code>。</p><p>如果是<strong>double</strong>，可以用<code>DBL_MAX</code>表示正无穷，<code>-DBL_MAX</code>表示负无穷(注意不是DBL_MIN)，需要包含<code>float.h</code></p><p>这里用Dev C++查出：</p><ul><li>INT_MAX = 2147483647 </li><li>INT_MIN = -2147483648 </li><li>DBL_MAX = 1.79769e+308 </li><li>-DBL_MAX = -1.79769e+308</li></ul><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200724221631.png" alt="测试图"></p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>好奇的扒了下Dev C++的limits.h和floa.h，发现里面还定义了不少其他的量：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200724222051.png" alt="limits.h"></p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200724222501.png" alt="flaot.h"></p><p>看来头文件里还是有很多秘密啊！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 无穷大 </tag>
            
            <tag> 头文件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode300. Longest Increasing Subsequence </title>
      <link href="/leetcode300-longest-increasing-subsequence/"/>
      <url>/leetcode300-longest-increasing-subsequence/</url>
      
        <content type="html"><![CDATA[<h2 id="题目：300-最长上升子序列"><a href="#题目：300-最长上升子序列" class="headerlink" title="题目：300. 最长上升子序列"></a>题目：<a href="https://leetcode-cn.com/problems/longest-increasing-subsequence/" target="_blank" rel="noopener">300. 最长上升子序列</a></h2><p>给定一个无序的整数数组，找到其中最长上升子序列的长度。</p><p>示例:</p><p>输入: <code>[10,9,2,5,3,7,101,18]</code><br>输出: <code>4</code><br>解释: 最长的上升子序列是 <code>[2,3,7,101]</code>，它的长度是 <code>4</code>。</p><h2 id="动态规划解法"><a href="#动态规划解法" class="headerlink" title="动态规划解法"></a>动态规划解法</h2><p>值得注意的是，要区分子序列和子串的概念，子串要求连续，而子序列没有这个要求。</p><p>我们定义dp数组为<code>dp[i]</code>，它表示的含义是以第<code>i</code>个数即<code>nums[i]</code>结尾的最长上升子序列的长度。</p><p>对于每一个子序列，显然它的最小长度为<code>1</code>即包含自身一个元素，所以我们的<strong>基础状态</strong><code>dp[i] = 1</code>。</p><p>接下来考虑状态转移方程：</p><p>假设我们求出了<code>dp[i-1]</code>，我们该如何求<code>dp[i]</code>呢？</p><p>既然要求是一个上升的子序列，那么必然需要从<code>nums[0]</code>到<code>nums[i-1]</code>找比<code>nums[i]</code>小的数作为子序列的前一项，从而构造出一个较长的子序列;想要达到最长子序列的目的，我们需要考虑所有可能的子序列，然后选出长度最大的即可。</p><p>我们可以写出：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200720162000.png" alt="状态转移方程"></p><p>求出以每个元素为结尾的最大上升子序列后，再遍历求出求大的子序列长度即为整个无序数组的最长上升子序列的长度。</p><p>代码为：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//dp数组全部初始化为1</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>i <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//求出最大的序列长度</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> d<span class="token operator">:</span>dp<span class="token punctuation">)</span><span class="token punctuation">{</span>            res <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这样的解法算法时间复杂度为<strong>O(n^2)</strong>，做到这里已经可以了，但实际上时间复杂度还可降到<strong>O(nlogn)</strong>，也就是下面扩展介绍的二分解法。</p><h2 id="二分查找解法"><a href="#二分查找解法" class="headerlink" title="二分查找解法"></a>二分查找解法</h2><p>明眼看，总感觉二分解法和这道题扯不上关系，其实有一种纸牌游戏叫做patience game，它的玩法与最长上升子序列有关系，以这种游戏为名还衍生出了一种排序算法：patience sorting。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200720164400.png" alt="patience sorting"></p><p>这个纸牌游戏也叫纸牌接龙，相信大家都玩过。</p><p>大佬的介绍：</p><p>首先，给你一排扑克牌，我们像遍历数组那样从左到右一张一张处理这些扑克牌，最终要把这些牌分成若干堆。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200720165821.webp" alt="poker1"></p><p><strong>处理这些扑克牌要遵循以下规则</strong>：</p><p>只能把点数小的牌压到点数比它大的牌上；如果当前牌点数较大没有可以放置的堆，则新建一个堆，把这张牌放进去；如果当前牌有多个堆可供选择，则选择最左边的那一堆放置。</p><p>比如说上述的扑克牌最终会被分成这样 5 堆（我们认为纸牌 A 的牌面是最大的，纸牌 2 的牌面是最小的）。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200720165827.webp" alt="poker2"></p><p>为什么遇到多个可选择堆的时候要放到最左边的堆上呢？稍加观察可以发现，<strong>这样可以保证牌堆顶的牌有序</strong>（2, 4, 7, 8, Q）。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200720165832.webp" alt="poker3"></p><p>按照上述规则执行，可以算出最长递增子序列，牌的堆数就是最长递增子序列的长度，<strong>因为如果从每堆拿出一张牌，就可以形成一个递增子序列。又因为每堆牌的值是递减的，所以这个递增子序列是最长的。</strong></p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200720165903.webp" alt="LIS"></p><p>我们只要把处理扑克牌的过程编程写出来即可。每次处理一张扑克牌不是要找一个合适的牌堆顶来放吗，牌堆顶的牌不是<strong>有序</strong>吗，这就能用到二分查找了：用二分查找来搜索当前牌应放置的位置，从而使算法时间复杂度降到<code>O(nlogn)</code>。</p><p>代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">lengthOfLIS</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//cards记录每堆牌的最下面的牌</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">cards</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//牌堆数初始为0</span>        <span class="token keyword">int</span> piles <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//开始摆牌</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//要处理的牌</span>            <span class="token keyword">int</span> poker <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> r <span class="token operator">=</span> piles<span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> mid <span class="token operator">=</span> l <span class="token operator">+</span> <span class="token punctuation">(</span>r <span class="token operator">-</span> l<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>cards<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">&lt;</span> poker<span class="token punctuation">)</span><span class="token punctuation">{</span>                    l <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>cards<span class="token punctuation">[</span>mid<span class="token punctuation">]</span> <span class="token operator">>=</span> poker<span class="token punctuation">)</span><span class="token punctuation">{</span>                    r <span class="token operator">=</span> mid<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//如果没找到合适牌堆，新建牌堆</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>l <span class="token operator">==</span> piles<span class="token punctuation">)</span> piles<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//更新cards</span>            cards<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> poker<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//牌堆数即为最长公共子序列长度</span>        <span class="token keyword">return</span> piles<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode322. Coin Change</title>
      <link href="/leetcode322-coin-change/"/>
      <url>/leetcode322-coin-change/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/coin-change/" target="_blank" rel="noopener">LeetCode322. Coin Change</a></p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p><strong>1、base case</strong></p><p>当目标金额<code>amount</code> 为0时，不需要任何硬币即可凑出。</p><p><strong>2、状态</strong></p><p>状态是会变化的量，这里显然有目标金额<code>amount</code>需要不断减少，向base case靠近，所以<code>amount</code>是唯一的状态。</p><p><strong>3、选择</strong></p><p>选择是导致状态变化的行为。我们需要对所有的硬币做尝试，选出能使硬币个数最少的方案。</p><p><strong>4、定义dp函数/数组</strong></p><p>这里自顶向下的解法定义为：</p><p><code>dp(n) = x</code>: 表示目标金额为n时，至少需要x个硬才币可以凑出。</p><p>由此写出状态转移方程：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200719161546.png" alt="状态转移方程"></p><h2 id="递归解法"><a href="#递归解法" class="headerlink" title="递归解法"></a>递归解法</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">dp</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">,</span> vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> memo<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>amount<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>amount<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//已经计算过，直接返回</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//未计算过则计算</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> INT_MAX<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> coin <span class="token operator">:</span> coins<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> sub <span class="token operator">=</span> <span class="token function">dp</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span>amount <span class="token operator">-</span> coin <span class="token punctuation">,</span>memo<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sub<span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            res <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>sub<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//更新memo</span>        memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>res<span class="token operator">==</span>INT_MAX<span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> res<span class="token punctuation">;</span>        <span class="token keyword">return</span> memo<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>amount<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//memo[n] = x ：amount= n的钱至少需要x个硬币凑出来</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">memo</span><span class="token punctuation">(</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">dp</span><span class="token punctuation">(</span>coins<span class="token punctuation">,</span> amount<span class="token punctuation">,</span> memo<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这里设的备忘录memo。</p><p>递归算法的时间复杂度为 <strong>子问题总数 x 每个子问题的时间</strong>。</p><p>子问题总数不超过金额数n，即子问题数目O(n)，处理一个子问题需要一个for循环，设时间O(k)。所以总时间复杂度为O(n*k)。</p><h2 id="迭代解法"><a href="#迭代解法" class="headerlink" title="迭代解法"></a>迭代解法</h2><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span><span class="token keyword">public</span><span class="token operator">:</span>    <span class="token keyword">int</span> <span class="token function">coinChange</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> coins<span class="token punctuation">,</span> <span class="token keyword">int</span> amount<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>amount<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//硬币面额为整数，即最小为1</span>        <span class="token comment" spellcheck="true">//所以硬币个数dp[?]最大不会超过目标金额数</span>        vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">dp</span><span class="token punctuation">(</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//base case</span>        dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">;</span>i <span class="token operator">&lt;</span> dp<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> coin<span class="token operator">:</span>coins<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">-</span>coin<span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">+</span>dp<span class="token punctuation">[</span>i<span class="token operator">-</span>coin<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span> <span class="token operator">==</span> amount<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> dp<span class="token punctuation">[</span>amount<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>dp</code> 数组的定义：当目标金额为 <code>i</code> 时，至少需要 <code>dp[i]</code> 枚硬币凑出。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 中等 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows更新npm和nodejs</title>
      <link href="/windows-geng-xin-npm-he-nodejs/"/>
      <url>/windows-geng-xin-npm-he-nodejs/</url>
      
        <content type="html"><![CDATA[<h2 id="查看当前npm和nodejs版本"><a href="#查看当前npm和nodejs版本" class="headerlink" title="查看当前npm和nodejs版本"></a>查看当前npm和nodejs版本</h2><pre class="line-numbers language-npm"><code class="language-npm">npm -vnode -v<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200718221823.png" alt="查看npm和node版本"></p><p>我更新前的版本，这里放出来做参考。</p><h2 id="升级npm版本"><a href="#升级npm版本" class="headerlink" title="升级npm版本"></a>升级npm版本</h2><pre class="line-numbers language-npm"><code class="language-npm">npm install -g npm  或者 npm install npm -g    #升级到最新版本npm install npm@latest -g    #升级到最新版本npm install npm@4.1.2 -g    #升级到指定版本<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200718220332.png" alt="npm升级到最新版本"></p><p>可以看到我升级前是v5.6.0，在执行升级到最新版本命令<code>npm install npm@latest -g</code>后变为v6.14.6。</p><h2 id="升级nodejs版本"><a href="#升级nodejs版本" class="headerlink" title="升级nodejs版本"></a>升级nodejs版本</h2><p>在<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">node官网</a>下载新版本node的 msi 安装包，然后覆盖安装之前的版本来完成更新操作。</p><p>注意安装路径要和之前的位置一致，如果不知道之前安装在哪个位置可以用命令<code>where node</code></p><pre class="line-numbers language-npm"><code class="language-npm">where node #查看nodejs安装位置<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200718221458.png" alt="查看node安装位置"></p><p>node官网下载安装完新版本nodejs后，使用命令<code>node -v</code>查看当前node版本</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200718221725.png" alt="查看当前node版本"></p><p>到这里npm和node就都更新升级完毕了。</p><p><strong>⚠踩坑警告</strong></p><p>我猜测在这步之前大家应该都没有问题（反正我是）。我按照网上广为流传的升级node方法：</p><p>使用<code>npm install -g n --force</code>的方法，安装 n 模块，node版本管理工具。<br>安装n模块：<code>npm install -g n</code>，执行后会报错</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200718222326.png" alt="安装n模块"></p><p>尝试使用强制安装命令：<code>npm install -g n --force</code>，好像成功了？？？</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200718223149.png" alt="强制安装n模块"></p><p>以为马上就要大功告成了，but！</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200718223151.png" alt="失败图"></p><p>这是什么原因呢，明明安装上了还没法用！</p><p>网上查到<a href="https://www.npmjs.com/package/n" target="_blank" rel="noopener">n模块官方</a>提示：</p><p> <code>Note: n is not supported natively on Windows.</code> Windows自然情况下是不支持n模块的。</p><p> 所以出现了上面虽然强制安装了，但是并不支持使用的情况。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> nodejs </tag>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git设置和取消代理</title>
      <link href="/git-she-zhi-he-qu-xiao-dai-li/"/>
      <url>/git-she-zhi-he-qu-xiao-dai-li/</url>
      
        <content type="html"><![CDATA[<h2 id="1、git设置代理"><a href="#1、git设置代理" class="headerlink" title="1、git设置代理"></a>1、git设置代理</h2><pre class="line-numbers language-git"><code class="language-git">git config --global https.proxy http://127.0.0.1:1088<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-git"><code class="language-git">git config --global https.proxy https://127.0.0.1:1088<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-git"><code class="language-git">git config --global https.proxy socks5://127.0.0.1:1088<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-git"><code class="language-git"><span class="token comment" spellcheck="true">#只对github.com</span>git config --global http.https://github.com.proxy socks5://127.0.0.1:1088<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>端口号替换成你自己的就行了。</p><h2 id="2、git取消代理"><a href="#2、git取消代理" class="headerlink" title="2、git取消代理"></a>2、git取消代理</h2><pre class="line-numbers language-git"><code class="language-git">git config --global --unset http.proxy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-git"><code class="language-git">git config --global --unset https.proxy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-git"><code class="language-git"><span class="token comment" spellcheck="true">#取消代理github.com</span>git config --global --unset http.https://github.com.proxy)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>参考：<strong><a href="https://gist.github.com/laispace/666dd7b27e9116faece6" target="_blank" rel="noopener">git 设置和取消代理</a></strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> proxy </tag>
            
            <tag> 代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode509.Fibonacci Number</title>
      <link href="/leetcode509.fibonacci-number/"/>
      <url>/leetcode509.fibonacci-number/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/fibonacci-number/" target="_blank" rel="noopener">LeetCode509.Fibonacci Number</a>  </p><h2 id="1、暴力递归"><a href="#1、暴力递归" class="headerlink" title="1、暴力递归"></a>1、暴力递归</h2><p>斐波那契数列的性质：</p><p><code>f1 = f2 = 1</code> </p><p><code>fn = fn-1 - fn-2</code></p><p>从这个性质我们可以写出<strong>状态转移方程</strong>为：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200717163705.png" alt=""></p><p>很容易我们写出代码：</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">||</span> N<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>N<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>N<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种写法很好想出，但算法时间复杂度非常高，指数级别，为<strong>O(2^N)</strong>。</p><p>原因是在递归的求解过程中有很多子问题被重复计算，这造成巨大的时间花费，使得算法变得十分低效。</p><h2 id="2、带备忘录的记忆化递归"><a href="#2、带备忘录的记忆化递归" class="headerlink" title="2、带备忘录的记忆化递归"></a>2、带备忘录的记忆化递归</h2><p>上一个解法提到提高解题效率的关键是如何消除子问题被重复计算。知道了这点，我们可以采用记<strong>备忘录</strong>的形式，每次求解子问题时，先不要着急计算，在备忘录中查询有无此子问题的答案，有的话直接返回结果；没有的话再递归求解子问题，同时将求解出的子问题答案记录在备忘录中。</p><p>这里使用一个vector数组当<strong>备忘录</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">calc</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span><span class="token operator">&amp;</span> memo<span class="token punctuation">,</span> <span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//如果memo[N]未计算过则计算，否则直接返回</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>memo<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>         memo<span class="token punctuation">[</span>N<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">calc</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span>N<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">calc</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span>N<span class="token number">-2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> memo<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">||</span> N<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//memo 数组做备忘录</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">memo</span><span class="token punctuation">(</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//base case</span>    memo<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> memo<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">calc</span><span class="token punctuation">(</span>memo<span class="token punctuation">,</span>N<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>有了memo备忘录存储每个子问题的计算结果，每次遇到相同子问题计算时直接查表即可。这样一来算法的时间复杂度大大降低了，为<strong>O(N)</strong>，算法的空间复杂度为<strong>O(N)</strong>。这在理论上已经达到了和动态规划的迭代解法一样的效率。</p><h2 id="3、自底向上的迭代法"><a href="#3、自底向上的迭代法" class="headerlink" title="3、自底向上的迭代法"></a>3、自底向上的迭代法</h2><p>可以发现刚才的两种解法都是考虑<strong>自上而下的递归式解法</strong>，即我们从结果的最终态出发，向问题的基础状态靠近，从而求解出答案。实际上我们还可以从基础状态出发，通过迭代向上求解，这样的方法叫<strong>自底向上的迭代法</strong>。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">||</span> N<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//memo 数组做备忘录</span>    vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">></span> <span class="token function">memo</span><span class="token punctuation">(</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    memo<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> memo<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        memo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> memo<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> memo<span class="token punctuation">[</span>i<span class="token number">-2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> memo<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>理论上，这种自底向上的迭代解法和自上而下的递归解法在时间复杂度方便是一样的，都是<strong>O(N)</strong>，但实际运行中，递归解法涉及较多的函数调用等耗费时间的操作，同样的问题规模可能要消耗稍微多一点时间。</p><p>一般来说，递归式的解法思路清晰，容易理解，迭代式的解法要求细节缜密，使用起来稍微复杂点，两者各有千秋。</p><h2 id="4、优化"><a href="#4、优化" class="headerlink" title="4、优化"></a>4、优化</h2><p>实际上，由斐波那契数的状态转移方程，我们可以发现每次求解的<strong>当前状态只与前两个状态有关系</strong>，即我们并不需要一整个备忘录表来存子问题的结果，只需要记住当前问题的前两个子问题结果。我们可以定义两个变量，每次利用这两个变量求出当前子问题的答案，再更新这两个变量，通过迭代获得问题的最终答案。</p><pre class="line-numbers language-cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">fib</span><span class="token punctuation">(</span><span class="token keyword">int</span> N<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>N<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">||</span> N<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//f1,f2存储前两个状态，res记录结果</span>    <span class="token keyword">int</span> f1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> f2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//根据前两个状态，计算当前状态值</span>        res <span class="token operator">=</span> f1 <span class="token operator">+</span> f2<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//更新前两个状态</span>        f1 <span class="token operator">=</span> f2<span class="token punctuation">;</span>        f2 <span class="token operator">=</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> res<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们通过只记录必要的数据来缩小DP table（即备忘录表）的大小，这个技巧被称为<strong>状态压缩</strong>。</p><p>通过优化，我们最终的时间复杂度为<strong>O(N)</strong>，空间复杂度为<strong>O(1)</strong>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> DP </tag>
            
            <tag> 力扣 </tag>
            
            <tag> 简单 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Feem：全平台支持的文件互传工具</title>
      <link href="/feem-quan-ping-tai-zhi-chi-de-wen-jian-hu-chuan-gong-ju/"/>
      <url>/feem-quan-ping-tai-zhi-chi-de-wen-jian-hu-chuan-gong-ju/</url>
      
        <content type="html"><![CDATA[<p>偶尔想手机、PC互传个文件，小文件啥的的用QQ到还是挺方便的，但我毕竟是个重度追剧患者，遇到一堆大点的视频传起来体验就不那么好了。比如把一部电影传到手机，首先就是在PC上先用QQ把文件先上传到QQ那边，手机那边再来下载，这一来一回折腾就很费时费力。今天给大家介绍的是一款号称全平台覆盖的文件互传工具：<a href="https://feem.io/" target="_blank" rel="noopener">Feem: Share Files Offline</a>。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200713105923.png" alt="Feem home"></p><h2 id="Core-Features"><a href="#Core-Features" class="headerlink" title="Core Features"></a>Core Features</h2><p>先来看看官方介绍：</p><h3 id="Blazingly-Fast"><a href="#Blazingly-Fast" class="headerlink" title="Blazingly Fast"></a>Blazingly Fast</h3><p>Transfer large files around you in record time. Feem is 50 times faster than Bluetooth. And around twice as fast as Dropbox.</p><p>传输速度比蓝牙快50倍，大约是Dropbox的两倍。</p><h3 id="Unlimited-File-Transfers"><a href="#Unlimited-File-Transfers" class="headerlink" title="Unlimited File Transfers"></a>Unlimited File Transfers</h3><p>Transfer large files around you without breaking the bank. Feem works device, directly to device. No Internet. No File Size Limits.</p><p>不需要Internet支持，也没有文件大小限制。</p><h3 id="Battle-tested-Security"><a href="#Battle-tested-Security" class="headerlink" title="Battle-tested Security"></a>Battle-tested Security</h3><p>Transfer sensitive files in your LAN, without the Cloud. There are no servers to hack into. Plus, Feem encrypts all local transfers with TLS (just like https://).</p><p>通过局域网传输，没有中间服务器，数据通过TLS加密，安全性高。</p><h3 id="All-Your-Devices-Covered"><a href="#All-Your-Devices-Covered" class="headerlink" title="All Your Devices, Covered"></a>All Your Devices, Covered</h3><p>Feem works on all major platforms including: iPhone, iPad, Android, Mac, Windows, Linux. You can Feem files from desktop to desktop, desktop to phone, phone to desktop, and phone to phone.</p><p>基本支持所有设备互传：iPhone, iPad, Android, Mac, Windows, Linux。</p><h3 id="Wi-Fi-Direct"><a href="#Wi-Fi-Direct" class="headerlink" title="Wi-Fi Direct"></a>Wi-Fi Direct</h3><p>Feem can work anywhere, even without a Wi-Fi router. Simply activate Wi-Fi direct inside Feem, or use your phone’s personal hotspot to create a network you can use to share files with.</p><p>即使没有路由器，也可通过设备创建热点方式互传。</p><h3 id="Resumable-File-Transfers"><a href="#Resumable-File-Transfers" class="headerlink" title="Resumable File Transfers"></a>Resumable File Transfers</h3><p>No one likes to restart an interrupted large file transfer. That’s why Feem will resume your file transfer right where you left it, without missing a byte. Saving you a lot of time and headache.</p><p>可恢复的文件传输，不怕传输中断。</p><h3 id="Works-Offline"><a href="#Works-Offline" class="headerlink" title="Works Offline"></a>Works Offline</h3><p>No data? No problem. Feem works completely offline. Your devices need to be running Feem, and should all be connected to the same Wi-Fi/Lan network.</p><p>只需连接同一局域网即可使用，文件传输零流量消耗。</p><h3 id="Chat"><a href="#Chat" class="headerlink" title="Chat"></a>Chat</h3><p>Send text and links directly between your devices. No servers involved. Completely secure. Your messages auto-destroy after 48 hours.</p><p>设备之间还可chat，消息48小时后自动删除。</p><h3 id="Feem-WebShare"><a href="#Feem-WebShare" class="headerlink" title="Feem WebShare"></a>Feem WebShare</h3><p>Don’t wish to install Feem on all your devices? No problem. Introducing Feem’s WebShare. With Feem’s Webshare, you can transfer sensitive documents around you using only your browser. Secured via https and PIN codes.</p><p>不想装app可以使用浏览器通过web界面传输。</p><h2 id="个人测评"><a href="#个人测评" class="headerlink" title="个人测评"></a>个人测评</h2><p>虽然使用时间还不长，但使用方便体验还是很不错的。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>免费，pro功能需要付费，但免费已经够用了</li><li>全平台覆盖，支持iPhone, iPad, Android, Mac, Windows, Linux等</li><li>传输速度快</li><li>安全，局域网传输，TLS加密</li></ul><h4 id="关于费用"><a href="#关于费用" class="headerlink" title="关于费用"></a>关于费用</h4><p>Feem基础版本免费，pro版本需要收费，价格如下：</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200713122224.png" alt="Feem Pro Price"></p><h4 id="全平台覆盖"><a href="#全平台覆盖" class="headerlink" title="全平台覆盖"></a>全平台覆盖</h4><p>从下图可以看到Feem支持了绝大多数平台，甚至连Linux都有。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200713111854.png" alt="平台支持"></p><h4 id="传输速度快"><a href="#传输速度快" class="headerlink" title="传输速度快"></a>传输速度快</h4><p>这里我只测试了<strong>Android手机</strong>、<strong>iPad</strong>、<strong>PC</strong>：</p><p>实测用<strong>电脑</strong>向<strong>iPad</strong>大约两分钟传输完一部2G的电影，传输速度甚至达到了<strong>30MB/s</strong>！</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200713121607.png" alt="PC2iPad测试图"></p><p>用<strong>Android手机</strong>向<strong>iPad</strong>传输一部138MB的MV大约几十秒，速度全程在5MB/s左右。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200713121605.png" alt="Android2iPad测试图"></p><p>速度方面真是没得说，主要用起来真的很方便，无线传输还解放了数据线。传输速度和<strong>路由器</strong>有关系，博主的路由器是Redmi AC2100，三个设备都是连接的5G频段的WiFi，路由器好些传输的要快些；和<strong>设备</strong>也有点关系，WiFi天线差的话可能要慢点。速度慢的话可以通过WiFi-Direct模式适当提速。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>主要是<strong>免费版</strong>才有缺点。</p><ul><li>轻度广告</li><li>不能自定义设备名字</li><li>不能自定义文件保存位置</li></ul><h4 id="广告"><a href="#广告" class="headerlink" title="广告"></a>广告</h4><p>广告这个吧，个人感觉还行，传输文件时会弹屏广告，不过广告可以手动关闭，并不影响传输。</p><h4 id="不可自定义XX"><a href="#不可自定义XX" class="headerlink" title="不可自定义XX"></a>不可自定义XX</h4><p>不可自定义设备名字倒是一点没有影响。不过不能自定义文件保存位置倒是有点令人蛋疼，有时可能需要传输完文件后手动迁移一下，值得一提的是移动端点击文件可以查看文件保存路径，PC端点击文件可以打开文件保存位置。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200713121555.png" alt="缺点"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>优点：</p><ul><li>免费，pro功能需要付费，但免费已经够用了</li><li>全平台覆盖，支持iPhone, iPad, Android, Mac, Windows, Linux等</li><li>传输速度快</li><li>安全，局域网传输，TLS加密</li></ul><p>缺点（免费版）：</p><ul><li>轻度广告</li><li>不能自定义设备名字</li><li>不能自定义文件保存位置</li></ul><p>整体来说，Feem算是相当良心了，用起来体验也是十分不错的，经常有文件互传方面需求的人士值得试用一下</p><p><a href="https://feem.io/#download" target="_blank" rel="noopener">Feem下载地址</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件互传 </tag>
            
            <tag> offline </tag>
            
            <tag> 免费 </tag>
            
            <tag> LAN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 删除博客文章</title>
      <link href="/hexo-shan-chu-wen-zhang/"/>
      <url>/hexo-shan-chu-wen-zhang/</url>
      
        <content type="html"><![CDATA[<p>刚刚接触博客，先尝试了下用 <code>hexo</code> + <code>github</code> 搭建了一个免费博客。虽然博客很早就搭起来了但是第一篇博客这两天才写出来。。毕竟还是小白操作啥的真是一窍不通，连删除博客文章都还不会，网上查阅了下记在这里权当备忘录了：</p><h2 id="删除文章的过程："><a href="#删除文章的过程：" class="headerlink" title="删除文章的过程："></a>删除文章的过程：</h2><ol><li><p>删除本地文件 xx.md</p></li><li><p>通过生成和部署命令进而将远程仓库中的文件也一并删除</p></li></ol><h2 id="实例讲解"><a href="#实例讲解" class="headerlink" title="实例讲解"></a>实例讲解</h2><p>具体来说，以最开始默认形成的helloworld.md这篇文章为例。</p><p>首先进入到存放博客的目录里source / _post 文件夹中，找到helloworld.md文件，在本地直接执行删除。然后依次执行<code>hexo g</code>，<code>hexo d</code>，再去主页查看你就会发现你的博客上面要删除的文章已经消失无踪了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MATLAB报错：未定义函数或变量</title>
      <link href="/matlab-bao-cuo-wei-ding-yi-han-shu-huo-bian-liang/"/>
      <url>/matlab-bao-cuo-wei-ding-yi-han-shu-huo-bian-liang/</url>
      
        <content type="html"><![CDATA[<p>最近准备数学建模比赛，学习MATLAB入门遇到了个问题：<code>未定义函数或变量 'myGcd'</code>。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200630173235.png" alt="MATLAB报错图片"></p><p>谷歌了下试了几个方案还是没解决。</p><p>参考官方的文档也没发现哪里有问题（其实是我一开始没看到）</p><p>小白真心累。</p><h2 id="常见错误原因"><a href="#常见错误原因" class="headerlink" title="常见错误原因"></a>常见错误原因</h2><p>先看看<strong>MATLAB官方文档</strong>：</p><p>这些错误通常指示 MATLAB 在当前目录或搜索路径中找不到特定的变量或 MATLAB 程序文件。其根本原因可能是下面这些原因中的一个：</p><ul><li>函数的名称拼写错误。</li><li>函数名称和包含函数的文件的名称不相同。</li><li>未安装函数所属的工具箱。</li><li>函数的搜索路径已更改。</li><li>函数是您没有许可证的工具箱的一部分。</li></ul><p>遇到此类错误时，请按照本节所述<strong>步骤</strong>来解决问题。</p><ol><li><p>验证函数名称的拼写</p></li><li><p>确保函数名称与文件名匹配</p></li><li><p>确保安装了工具箱</p></li><li><p>验证访问函数所用的路径</p></li></ol><p> 这里不做具体解释，详情请移步官网：<a href="https://ww2.mathworks.cn/help/matlab/matlab_prog/calling-functions.html" target="_blank" rel="noopener">MATLAB-调用函数时的常见错误</a></p><h2 id="我的解决方案"><a href="#我的解决方案" class="headerlink" title="我的解决方案"></a>我的解决方案</h2><p>当时有点急了，文档都是跳着看（真的要认真看文档啊！！！），我先是试了1，4步骤，结果都没解决问题。</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200630173430.png" alt=""></p><p>最后沉下心来，看了下自己写的几个脚本，其中写了两个函数，一个是myFun，另一个是myGcd，我在想为什么我的myFun就能用，我的myGcd就不行。看着看着发现了端倪！我的myGcd<strong>函数名称和文件名不一样</strong>！也就是MATLAB官方给的帮助文档里的第2条。</p><p>我<strong>把文件名改成和函数名一样</strong>就正常使用，没有问题了！</p><p><img src="https://gitee.com/deardeer7/MyPic/raw/master/img/20200630173511.png" alt="问题解决图片"></p><p>小问题多耽误半天时间，哎，希望我的经历有帮到你！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 数学建模 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MATLAB </tag>
            
            <tag> 函数报错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/hello-world/"/>
      <url>/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hello World </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
